        -:    0:Source:drinks_bar.c
        -:    0:Graph:./drinks_bar.gcno
        -:    0:Data:./drinks_bar.gcda
        -:    0:Runs:33
        -:    1:/*
        -:    2:** drinks_bar.c -- a combined TCP+UDP server for:
        -:    3:**   • TCP ADD CARBON / ADD OXYGEN / ADD HYDROGEN (Stage 1)
        -:    4:**   • UDP DELIVER WATER / CARBON DIOXIDE / GLUCOSE / ALCOHOL (Stage 2)
        -:    5:**   • console commands to tell how many beverages (SOFT DRINK, VODKA, CHAMPAGNE) can be made (Stage 3)
        -:    6:**   • optionally also accept UDS‐STREAM (‐s) or UDS‐DGRAM (‐d) like UDP/TCP
        -:    7:**
        -:    8:** Mandatory flags: 
        -:    9:**   -c <initial_carbon> 
        -:   10:**   -o <initial_oxygen> 
        -:   11:**   -h <initial_hydrogen>
        -:   12:**   -T <tcp_port> 
        -:   13:**   -U <udp_port>
        -:   14:**
        -:   15:** Optional: 
        -:   16:**   -t <timeout_seconds>
        -:   17:**   -s <uds_stream_path>   (if you want a Unix‐domain STREAM socket in addition to TCP+UDP)
        -:   18:**   -d <uds_dgram_path>    (if you want a Unix‐domain DGRAM socket in addition to TCP+UDP)
        -:   19:**
        -:   20:** Examples:
        -:   21:**   ./drinks_bar -c 100 -o 50 -h 200 -T 5555 -U 6666
        -:   22:**     (only TCP on 5555 and UDP on 6666)
        -:   23:**
        -:   24:**   ./drinks_bar -c 10 -o 10 -h 10 -T 5555 -U 6666 -s /tmp/my_stream.sock
        -:   25:**     (TCP/UDP plus a UDS-STREAM socket at /tmp/my_stream.sock)
        -:   26:**
        -:   27:**   ./drinks_bar -c 10 -o 10 -h 10 -T 5555 -U 6666 -d /tmp/my_dgram.sock
        -:   28:**     (TCP/UDP plus a UDS-DGRAM socket at /tmp/my_dgram.sock)
        -:   29:**
        -:   30:*/
        -:   31:
        -:   32:#include <stdio.h>           // printf, fprintf, perror
        -:   33:#include <stdlib.h>          // exit, malloc, free
        -:   34:#include <string.h>          // strlen, strcmp, strtok_r, strncpy, snprintf, memset, memcpy
        -:   35:#include <stdint.h>          // uint64_t
        -:   36:#include <stdbool.h>         // bool, true, false
        -:   37:#include <unistd.h>          // close, fork, write, unlink, STDIN_FILENO
        -:   38:#include <errno.h>           // errno
        -:   39:#include <sys/types.h>       // socklen_t
        -:   40:#include <sys/socket.h>      // socket, bind, listen, accept, send, recv, sendto, recvfrom
        -:   41:#include <sys/un.h>          // sockaddr_un
        -:   42:#include <netdb.h>           // getaddrinfo, freeaddrinfo, struct addrinfo
        -:   43:#include <arpa/inet.h>       // inet_ntop
        -:   44:#include <netinet/in.h>      // sockaddr_in, sockaddr_in6
        -:   45:#include <sys/select.h>      // select, fd_set, FD_ZERO, FD_SET, FD_ISSET
        -:   46:#include <sys/wait.h>        // waitpid, WNOHANG
        -:   47:#include <signal.h>          // sigaction, SIGCHLD, SIGALRM
        -:   48:#include <getopt.h>          // getopt_long
        -:   49:#include <stddef.h>          // offsetof
        -:   50:#include <sys/file.h>   // flock
        -:   51:#include <fcntl.h>
        -:   52:#include <sys/stat.h>
        -:   53:
        -:   54:#define MAX_ATOMS  ((uint64_t)1000000000000000000ULL)  // 10^18 maximum quantity
        -:   55:#define BACKLOG    10                                   // TCP listen backlog
        -:   56:#define MAX_CLIENTS FD_SETSIZE                           // max simultaneous TCP clients
        -:   57:#define MAXBUF     1024                                  // buffer size for recv/send
        -:   58:
        -:   59:// ----------------------------------------------------------------------------
        -:   60:// Struct to store counts of each atom type (Stage 1)
        -:   61:// ----------------------------------------------------------------------------
        -:   62:typedef struct {
        -:   63:    uint64_t carbon;    // count of carbon atoms
        -:   64:    uint64_t oxygen;    // count of oxygen atoms
        -:   65:    uint64_t hydrogen;  // count of hydrogen atoms
        -:   66:} AtomStock;
        -:   67:
        -:   68:
        -:   69:// Global atomic stock (initialized via flags -c, -o, -h)
        -:   70:static AtomStock atom_stock = { 0, 0, 0 };
        -:   71:
        -:   72:// A simple flag set by SIGALRM to signal “timeout” (Stage 4)
        -:   73:static volatile sig_atomic_t timed_out = 0;
        -:   74:
        -:   75://if we will have -f flag than we will save here the path of the file to load/save the atoms from.
        -:   76:static char *save_file_path = NULL;
        -:   77:
        -:   78:// ----------------------------------------------------------------------------
        -:   79:// Prototypes
        -:   80:// ----------------------------------------------------------------------------
        -:   81:
        -:   82:// SIGCHLD handler: reap any zombie children
        -:   83:void sigchld_handler(int sig);
        -:   84:
        -:   85:// SIGALRM handler: mark that timeout occurred
        -:   86:void alarm_handler(int sig);
        -:   87:
        -:   88:// Get the “address field” portion (IPv4 or IPv6) from sockaddr*
        -:   89:void *get_in_addr(struct sockaddr *sa);
        -:   90:
        -:   91:// Print the current stock of atoms to stdout
        -:   92:void print_inventory(void);
        -:   93:
        -:   94:// Handle exactly one TCP client command on `client_fd` (an “ADD …” line).
        -:   95:// - Reads one line, parses “ADD <TYPE> <NUM>\n”
        -:   96:// - Updates atom_stock
        -:   97:// - Sends back either “OK: Carbon=… Oxygen=… Hydrogen=…\n” or “ERROR: …\n”
        -:   98:// Returns false if the client closed connection or a read‐error occurred.
        -:   99:bool handle_tcp_client(int client_fd);
        -:  100:
        -:  101:// Parse a single “ADD <TYPE> <NUM>” line (no trailing newline), update atom_stock.
        -:  102:// Fill `response` with either
        -:  103://   “OK: Carbon=.. Oxygen=.. Hydrogen=..\n”
        -:  104:// or “ERROR: ...\n”
        -:  105:void parse_and_update_tcp(const char *line, char *response, size_t resp_size);
        -:  106:
        -:  107:// Parse a single “DELIVER <MOLECULE> <NUM>” line, check atom stock,
        -:  108:// subtract required atoms if possible, and fill `response` with
        -:  109://   “OK: Atoms left – Carbon=.. Oxygen=.. Hydrogen=..\n”
        -:  110:// or “ERROR: ...\n”
        -:  111:void parse_and_update_udp(const char *line, char *response, size_t resp_size);
        -:  112:
        -:  113://if the file exists and big enough , reads sizeof (atomStock) to the global var.
        -:  114://else creating a new file , fills it with the values of the atoms and read the full struct to the file.
        -:  115:static void load_atoms_from_file(const char *path, uint64_t init_c,uint64_t init_o,uint64_t init_h);
        -:  116:
        -:  117:
        -:  118://opens / creates the file in rb or wb. locks the file with flock to prevent parallel changes.
        -:  119://writes a block of our atoms struct with fwrite.
        -:  120://releases the lock and closes the files.
        -:  121:static void save_atoms_to_file(const char *path);
        -:  122:
        -:  123:// ----------------------------------------------------------------------------
        -:  124:// SIGALRM handler: marks that we timed out (no activity for <timeout> seconds).
        -:  125:// We use write() (async‐signal safe) just to print a quick message.
        -:  126:// ----------------------------------------------------------------------------
        2:  127:void alarm_handler(int sig) {
        -:  128:    (void)sig;
        2:  129:    const char msg[] = ">>> Alarm handler invoked! Server shutting down due to inactivity.\n";
        2:  130:    write(STDOUT_FILENO, msg, sizeof(msg) - 1);
        2:  131:    timed_out = 1;
        2:  132:}
        -:  133:
        -:  134:// ----------------------------------------------------------------------------
        -:  135:// Print the current atom inventory on stdout.
        -:  136:// ----------------------------------------------------------------------------
       33:  137:void print_inventory(void) {
       33:  138:    printf("SERVER INVENTORY (atoms): Carbon=%llu  Oxygen=%llu  Hydrogen=%llu\n",
       33:  139:           (unsigned long long)atom_stock.carbon,
       33:  140:           (unsigned long long)atom_stock.oxygen,
       33:  141:           (unsigned long long)atom_stock.hydrogen);
       33:  142:}
        -:  143:
        -:  144:// ----------------------------------------------------------------------------
        -:  145:// Parse and update a TCP “ADD <TYPE> <NUM>” command.
        -:  146:// Fills `response` with either “OK: Carbon=.. Oxygen=.. Hydrogen=..\n”
        -:  147:// or an ERROR line.
        -:  148:// ----------------------------------------------------------------------------
       15:  149:void parse_and_update_tcp(const char *line, char *response, size_t resp_size) {
        -:  150:
       15:  151:    if (save_file_path) {
       15:  152:        load_atoms_from_file(save_file_path, 0, 0, 0);
        -:  153:    }
        -:  154:    
        -:  155:    
        -:  156:    char temp[MAXBUF];
       15:  157:    strncpy(temp, line, sizeof(temp));
       15:  158:    temp[sizeof(temp)-1] = '\0';
        -:  159:
       15:  160:    char *saveptr = NULL;
       15:  161:    char *token_cmd  = strtok_r(temp, " \t\r\n", &saveptr);  // “ADD”
       15:  162:    char *token_type = strtok_r(NULL,   " \t\r\n", &saveptr);  // “CARBON”|“OXYGEN”|“HYDROGEN”
       15:  163:    char *token_num  = strtok_r(NULL,   " \t\r\n", &saveptr);  // e.g. “100”
        -:  164:
       15:  165:    if (!token_cmd || !token_type || !token_num) {
    #####:  166:        snprintf(response, resp_size, "ERROR: invalid command\n");
       4*:  167:        return;
        -:  168:    }
       15:  169:    if (strcmp(token_cmd, "ADD") != 0) {
        1:  170:        snprintf(response, resp_size, "ERROR: invalid command\n");
        1:  171:        return;
        -:  172:    }
        -:  173:
       14:  174:    enum { CARBON, OXYGEN, HYDROGEN, TYPE_UNKNOWN } type = TYPE_UNKNOWN;
       14:  175:    if (strcmp(token_type, "CARBON") == 0)      type = CARBON;
        7:  176:    else if (strcmp(token_type, "OXYGEN") == 0) type = OXYGEN;
        4:  177:    else if (strcmp(token_type, "HYDROGEN") == 0) type = HYDROGEN;
        -:  178:    else {
        1:  179:        snprintf(response, resp_size, "ERROR: invalid atom type\n");
        1:  180:        return;
        -:  181:    }
        -:  182:
       13:  183:    char *endptr = NULL;
       13:  184:    unsigned long long val = strtoull(token_num, &endptr, 10);
       13:  185:    if (endptr == token_num || *endptr != '\0') {
        1:  186:        snprintf(response, resp_size, "ERROR: invalid number\n");
        1:  187:        return;
        -:  188:    }
       12:  189:    if (val > MAX_ATOMS) {
        1:  190:        snprintf(response, resp_size, "ERROR: number too large\n");
        1:  191:        return;
        -:  192:    }
        -:  193:
        -:  194:    // Attempt to add to the correct stock, checking for overflow.
       11:  195:    switch (type) {
        6:  196:        case CARBON:
        6:  197:            if (atom_stock.carbon + val > MAX_ATOMS) {
    #####:  198:                snprintf(response, resp_size, "ERROR: capacity exceeded\n");
    #####:  199:                return;
        -:  200:            }
        6:  201:            atom_stock.carbon += val;
        6:  202:            break;
        2:  203:        case OXYGEN:
        2:  204:            if (atom_stock.oxygen + val > MAX_ATOMS) {
    #####:  205:                snprintf(response, resp_size, "ERROR: capacity exceeded\n");
    #####:  206:                return;
        -:  207:            }
        2:  208:            atom_stock.oxygen += val;
        2:  209:            break;
        3:  210:        case HYDROGEN:
        3:  211:            if (atom_stock.hydrogen + val > MAX_ATOMS) {
    #####:  212:                snprintf(response, resp_size, "ERROR: capacity exceeded\n");
    #####:  213:                return;
        -:  214:            }
        3:  215:            atom_stock.hydrogen += val;
        3:  216:            break;
    #####:  217:        default:
    #####:  218:            snprintf(response, resp_size, "ERROR: unknown error\n");
    #####:  219:            return;
        -:  220:    }
        -:  221:
        -:  222:    // Print updated atom inventory to server console
       11:  223:    printf("SERVER INVENTORY (atoms): Carbon=%llu  Oxygen=%llu  Hydrogen=%llu\n",
       11:  224:           (unsigned long long)atom_stock.carbon,
       11:  225:           (unsigned long long)atom_stock.oxygen,
       11:  226:           (unsigned long long)atom_stock.hydrogen);
        -:  227:
        -:  228:    //if there is a save flag , we will save the atoms to the file.
       11:  229:    if (save_file_path) {
       11:  230:        save_atoms_to_file(save_file_path);
        -:  231:    }
        -:  232:
        -:  233:    // Build success response
       11:  234:    snprintf(response, resp_size,
        -:  235:             "OK: Carbon=%llu Oxygen=%llu Hydrogen=%llu\n",
       11:  236:             (unsigned long long)atom_stock.carbon,
       11:  237:             (unsigned long long)atom_stock.oxygen,
       11:  238:             (unsigned long long)atom_stock.hydrogen);
        -:  239:}
        -:  240:
        -:  241:// ----------------------------------------------------------------------------
        -:  242:// Parse and update a UDP “DELIVER <MOLECULE> <NUM>” command.
        -:  243:// Molecule → needs certain numbers of atoms; subtract if enough atoms; else error.
        -:  244:// Print the resulting inventory, then respond with a short “OK: Atoms left …\n”
        -:  245:// ----------------------------------------------------------------------------
       32:  246:void parse_and_update_udp(const char *line, char *response, size_t resp_size) {  
        -:  247:    
       32:  248:    if (save_file_path) {
       32:  249:        load_atoms_from_file(save_file_path, 0, 0, 0);
        -:  250:    }
        -:  251:    
        -:  252:    char temp[MAXBUF];
       32:  253:    strncpy(temp, line, sizeof(temp));
       32:  254:    temp[sizeof(temp)-1] = '\0';
        -:  255:
       32:  256:    char *saveptr = NULL;
       32:  257:    char *token_cmd = strtok_r(temp, " \t\r\n", &saveptr);  // “DELIVER”
       32:  258:    char *token_mol = strtok_r(NULL,   " \t\r\n", &saveptr);  // e.g. “WATER” or “CARBON”
        -:  259:
       32:  260:    if (!token_cmd || !token_mol) {
        2:  261:        snprintf(response, resp_size, "ERROR: invalid command\n");
       27:  262:        return;
        -:  263:    }
       30:  264:    if (strcmp(token_cmd, "DELIVER") != 0) {
        2:  265:        snprintf(response, resp_size, "ERROR: invalid command\n");
        2:  266:        return;
        -:  267:    }
        -:  268:
        -:  269:    // Build full molecule name if needed (“CARBON DIOXIDE” → two tokens)
        -:  270:    char full_mol[MAXBUF];
       28:  271:    if (strcmp(token_mol, "CARBON") == 0) {
        5:  272:        char *token_next = strtok_r(NULL, " \t\r\n", &saveptr);
        5:  273:        if (!token_next || strcmp(token_next, "DIOXIDE") != 0) {
    #####:  274:            snprintf(response, resp_size, "ERROR: invalid molecule type\n");
    #####:  275:            return;
        -:  276:        }
        5:  277:        strcpy(full_mol, "CARBON DIOXIDE");
        -:  278:    }
       23:  279:    else if (strcmp(token_mol, "WATER") == 0) {
       14:  280:        strcpy(full_mol, "WATER");
        -:  281:    }
        9:  282:    else if (strcmp(token_mol, "GLUCOSE") == 0) {
        4:  283:        strcpy(full_mol, "GLUCOSE");
        -:  284:    }
        5:  285:    else if (strcmp(token_mol, "ALCOHOL") == 0) {
        2:  286:        strcpy(full_mol, "ALCOHOL");
        -:  287:    }
        -:  288:    else {
        3:  289:        snprintf(response, resp_size, "ERROR: invalid molecule type\n");
        3:  290:        return;
        -:  291:    }
        -:  292:
        -:  293:    // Next token must be a number
       25:  294:    char *token_num = strtok_r(NULL, " \t\r\n", &saveptr);
       25:  295:    if (!token_num) {
        2:  296:        snprintf(response, resp_size, "ERROR: missing number\n");
        2:  297:        return;
        -:  298:    }
        -:  299:    // Ensure no extra tokens
       23:  300:    char *token_extra = strtok_r(NULL, " \t\r\n", &saveptr);
       23:  301:    if (token_extra) {
        2:  302:        snprintf(response, resp_size, "ERROR: too many arguments\n");
        2:  303:        return;
        -:  304:    }
        -:  305:
       21:  306:    char *endptr = NULL;
       21:  307:    unsigned long long count = strtoull(token_num, &endptr, 10);
       21:  308:    if (endptr == token_num || *endptr != '\0') {
        2:  309:        snprintf(response, resp_size, "ERROR: invalid number\n");
        2:  310:        return;
        -:  311:    }
       19:  312:    if (count > MAX_ATOMS) {
        2:  313:        snprintf(response, resp_size, "ERROR: number too large\n");
        2:  314:        return;
        -:  315:    }
        -:  316:
        -:  317:    // Compute needed atoms for one molecule × count
       17:  318:    uint64_t req_carbon = 0, req_oxygen = 0, req_hydrogen = 0;
       17:  319:    if (strcmp(full_mol, "WATER") == 0) {
        -:  320:        // H2O: needs 2 H + 1 O per molecule
        6:  321:        req_hydrogen = 2ULL * count;
        6:  322:        req_oxygen   = 1ULL * count;
        6:  323:        req_carbon   = 0ULL;
        -:  324:    }
       11:  325:    else if (strcmp(full_mol, "CARBON DIOXIDE") == 0) {
        -:  326:        // CO2: needs 1 C + 2 O per molecule
        5:  327:        req_carbon   = 1ULL * count;
        5:  328:        req_oxygen   = 2ULL * count;
        5:  329:        req_hydrogen = 0ULL;
        -:  330:    }
        6:  331:    else if (strcmp(full_mol, "GLUCOSE") == 0) {
        -:  332:        // C6H12O6: needs 6 C + 12 H + 6 O per molecule
        4:  333:        req_carbon   = 6ULL * count;
        4:  334:        req_hydrogen = 12ULL * count;
        4:  335:        req_oxygen   = 6ULL * count;
        -:  336:    }
        2:  337:    else if (strcmp(full_mol, "ALCOHOL") == 0) {
        -:  338:        // C2H6O: needs 2 C + 6 H + 1 O per molecule
        2:  339:        req_carbon   = 2ULL * count;
        2:  340:        req_hydrogen = 6ULL * count;
        2:  341:        req_oxygen   = 1ULL * count;
        -:  342:    }
        -:  343:    else {
    #####:  344:        snprintf(response, resp_size, "ERROR: unknown molecule\n");
    #####:  345:        return;
        -:  346:    }
        -:  347:
        -:  348:    // Check if enough atoms exist
       17:  349:    if (atom_stock.carbon   < req_carbon) {
        5:  350:        snprintf(response, resp_size, "ERROR: not enough carbon atoms\n");
        5:  351:        return;
        -:  352:    }
       12:  353:    if (atom_stock.oxygen   < req_oxygen) {
        5:  354:        snprintf(response, resp_size, "ERROR: not enough oxygen atoms\n");
        5:  355:        return;
        -:  356:    }
        7:  357:    if (atom_stock.hydrogen < req_hydrogen) {
        2:  358:        snprintf(response, resp_size, "ERROR: not enough hydrogen atoms\n");
        2:  359:        return;
        -:  360:    }
        -:  361:
        -:  362:    // Subtract the required atoms
        5:  363:    atom_stock.carbon   -= req_carbon;
        5:  364:    atom_stock.oxygen   -= req_oxygen;
        5:  365:    atom_stock.hydrogen -= req_hydrogen;
        -:  366:
        -:  367:    // Print updated inventory 
        5:  368:    print_inventory();
        -:  369:
        -:  370:    //if there is a save flag , we will save the atoms to the file.
        5:  371:    if (save_file_path) {
        5:  372:        save_atoms_to_file(save_file_path);
        -:  373:    }
        -:  374:
        -:  375:    // Respond with a short “OK: Atoms left – Carbon=.. Oxygen=.. Hydrogen=..\n”
        5:  376:    snprintf(response, resp_size,
        -:  377:             "OK: Atoms left – Carbon=%llu Oxygen=%llu Hydrogen=%llu\n",
        5:  378:             (unsigned long long)atom_stock.carbon,
        5:  379:             (unsigned long long)atom_stock.oxygen,
        5:  380:             (unsigned long long)atom_stock.hydrogen);
        -:  381:}
        -:  382:
        -:  383:// ----------------------------------------------------------------------------
        -:  384:// handle_tcp_client():
        -:  385://   - read exactly one “ADD …” line (via recv), 
        -:  386://   - call parse_and_update_tcp(…), 
        -:  387://   - send the response back over that same TCP socket.
        -:  388:// Return false if client closed or a recv‐error occurred.
        -:  389:// ----------------------------------------------------------------------------
       29:  390:bool handle_tcp_client(int client_fd) {
        -:  391:    char buf[MAXBUF];
       29:  392:    ssize_t numbytes = recv(client_fd, buf, sizeof(buf)-1, 0);
       29:  393:    if (numbytes <= 0) {
        -:  394:        // 0 => client closed; <0 => recv error
       14:  395:        return false;
        -:  396:    }
       15:  397:    buf[numbytes] = '\0';
        -:  398:
        -:  399:    char response[MAXBUF];
       15:  400:    parse_and_update_tcp(buf, response, sizeof(response));
        -:  401:
       15:  402:    if (send(client_fd, response, strlen(response), 0) < 0) {
    #####:  403:        perror("send (TCP)");
        -:  404:    }
       15:  405:    return true;
        -:  406:}
        -:  407:// ----------------------------------------------------------------------------
        -:  408:// load_atoms_from_file():
        -:  409://      if the file exists and big enough , reads sizeof (atomStock) to the global var.
        -:  410://      else creating a new file , fills it with the values of the atoms and read the full struct to the file.
        -:  411:// ----------------------------------------------------------------------------
       76:  412:static void load_atoms_from_file(const char *path, uint64_t init_c, uint64_t init_o,uint64_t init_h)
        -:  413:{
        -:  414:    struct stat st;
        -:  415:    FILE *fp;
        -:  416:
        -:  417:    //if the file exists
       76:  418:    if (stat(path,&st) == 0){
       75:  419:        if(st.st_size >= (off_t)sizeof(atom_stock)){
        -:  420:            //reading all the struct from the file:
       63:  421:            fp = fopen(path,"rb");
       63:  422:            if (!fp){
    #####:  423:                perror("fopen (for read)");
    #####:  424:                exit(EXIT_FAILURE);
        -:  425:            }
       63:  426:            size_t n = fread(&atom_stock,1,sizeof(AtomStock),fp);
       63:  427:            if (n != sizeof(AtomStock)){
    #####:  428:                fprintf(stderr,"Error:could not read Atoms from file \n");
    #####:  429:                fclose(fp);
    #####:  430:                exit(EXIT_FAILURE);
        -:  431:            }
       63:  432:            fclose(fp);
       63:  433:            return;
        -:  434:        }
        -:  435:        //if file is too small , we will drop to create a new file.
        -:  436:    }
        -:  437:
        -:  438:    //if we reach here , file not exists or too small -> creating a new file :
       13:  439:    atom_stock.carbon = init_c;
       13:  440:    atom_stock.oxygen = init_o;
       13:  441:    atom_stock.hydrogen = init_h;
        -:  442:
       13:  443:    fp = fopen(path, "wb");
       13:  444:    if (!fp) {
    #####:  445:        perror("fopen for write");
    #####:  446:        exit(EXIT_FAILURE);
        -:  447:    }
       13:  448:    size_t w = fwrite(&atom_stock,1,sizeof(AtomStock),fp);
       13:  449:    if (w != sizeof(AtomStock)){
    #####:  450:        fprintf(stderr,"Error: could not write full Atoms struct to file \n");
    #####:  451:        fclose(fp);
    #####:  452:        exit(EXIT_FAILURE);
        -:  453:    }
       13:  454:    fclose(fp);
        -:  455:}
        -:  456:
        -:  457:
        -:  458:// ----------------------------------------------------------------------------
        -:  459:// save_atoms_to_file():
        -:  460://opens / creates the file in rb or wb. locks the file with flock to prevent parallel changes.
        -:  461://writes a block of our atoms struct with fwrite.
        -:  462://releases the lock and closes the files.
        -:  463:// ----------------------------------------------------------------------------
       18:  464:static void save_atoms_to_file(const char *path){
       18:  465:    FILE *fp = fopen(path,"r+b");
       18:  466:    if (!fp) { //if file does not exits we will try to create it
    #####:  467:        fp = fopen(path,"w+b");
    #####:  468:        if(!fp){
    #####:  469:            perror("fopen for save");
    #####:  470:            return;
        -:  471:        }
        -:  472:    }
        -:  473:
       18:  474:    int fd = fileno(fp); // should understand later
       18:  475:    if (fd < 0) {
    #####:  476:        perror("fileno");
    #####:  477:        fclose(fp);
    #####:  478:        return;
        -:  479:    }
        -:  480:
        -:  481:    //exlusive lock:
       18:  482:    if (flock(fd,LOCK_EX) < 0){
    #####:  483:        perror("flock LOCK_EX");
        -:  484:        //might be risky but we will keep going :D
        -:  485:    }
        -:  486:
        -:  487:    //writing:
       18:  488:    if (fseek(fp,0,SEEK_SET)!= 0)
    #####:  489:        perror("fseek");
       18:  490:    size_t w = fwrite(&atom_stock,1,sizeof(AtomStock),fp);
       18:  491:    if (w!=sizeof(AtomStock))
    #####:  492:        fprintf(stderr, "Error: could not write full Atom struct\n");
       18:  493:    fflush(fp);
        -:  494:
        -:  495:    //releasing the lock:
       18:  496:    if (flock(fd, LOCK_UN) < 0) {
    #####:  497:        perror("flock LOCK_UN");
        -:  498:    }
       18:  499:    fclose(fp);
        -:  500:
        -:  501:}   
        -:  502:
        -:  503:
        -:  504:
        -:  505:
        -:  506:
        -:  507:
        -:  508:// ----------------------------------------------------------------------------
        -:  509:// main():
        -:  510://   • parse flags (−c, −o, −h, −t, −T, −U, optionally −s or −d)
        -:  511://   • set up atom_stock
        -:  512://   • possibly install SIGALRM
        -:  513://   • create and bind TCP listen socket on port T
        -:  514://   • create and bind UDP socket on port U
        -:  515://   • optionally create & bind UDS‐STREAM if −s was given
        -:  516://   • optionally create & bind UDS‐DGRAM if −d was given
        -:  517://   • enter select() loop: monitor 
        -:  518://       – tcp_listen_fd, 
        -:  519://       – udp_fd, 
        -:  520://       – any accepted TCP client fds, 
        -:  521://       – STDIN_FILENO, 
        -:  522://       – uds_stream_fd (if set), 
        -:  523://       – uds_dgram_fd (if set).
        -:  524://   • on tcp_listen_fd ready: accept new connection, add to client list
        -:  525://   • on udp_fd ready: recvfrom, parse_and_update_udp, sendto reply
        -:  526://   • on any TCP client fd ready: call handle_tcp_client()
        -:  527://   • on STDIN_FILENO ready: handle “GEN …” console commands
        -:  528://   • on uds_stream_fd ready: accept a UDS‐STREAM connection, call handle_tcp_client() over it, close it
        -:  529://   • on uds_dgram_fd ready: recvfrom a “DELIVER …” datagram from a UDS client, parse_and_update_udp, sendto reply back to that UDS client
        -:  530://   • if timeout triggered, break out and clean up
        -:  531:// ----------------------------------------------------------------------------
       33:  532:int main(int argc, char *argv[]) {
        -:  533:    // 1) Parse command‐line options
       33:  534:    uint64_t init_carbon   = 0;
       33:  535:    uint64_t init_oxygen   = 0;
       33:  536:    uint64_t init_hydrogen = 0;
       33:  537:    int timeout_secs       = 0;
       33:  538:    int tcp_port           = -1;
       33:  539:    int udp_port           = -1;
       33:  540:    char *uds_stream_path  = NULL;
       33:  541:    char *uds_dgram_path   = NULL;
        -:  542:
       33:  543:    struct option long_opts[] = {
        -:  544:        {"carbon",       required_argument, 0, 'c'},
        -:  545:        {"oxygen",       required_argument, 0, 'o'},
        -:  546:        {"hydrogen",     required_argument, 0, 'h'},
        -:  547:        {"timeout",      required_argument, 0, 't'},
        -:  548:        {"tcp-port",     required_argument, 0, 'T'},
        -:  549:        {"udp-port",     required_argument, 0, 'U'},
        -:  550:        {"stream-path",  required_argument, 0, 's'},
        -:  551:        {"datagram-path",required_argument, 0, 'd'},
        -:  552:        {"save-file",required_argument, 0, 'f'},
        -:  553:        {0,0,0,0}
        -:  554:    };
       33:  555:    const char *short_opts = "c:o:h:t:T:U:s:d:f:";
        -:  556:    int opt;
      210:  557:    while ((opt = getopt_long(argc, argv, short_opts, long_opts, NULL)) != -1) {
      179:  558:        switch (opt) {
       31:  559:            case 'c':
       31:  560:                init_carbon = strtoull(optarg, NULL, 10);
       31:  561:                break;
       31:  562:            case 'o':
       31:  563:                init_oxygen = strtoull(optarg, NULL, 10);
       31:  564:                break;
       31:  565:            case 'h':
       31:  566:                init_hydrogen = strtoull(optarg, NULL, 10);
       31:  567:                break;
        2:  568:            case 't':
        2:  569:                timeout_secs = atoi(optarg);
        2:  570:                break;
       31:  571:            case 'T':
       31:  572:                tcp_port = atoi(optarg);
       31:  573:                break;
       31:  574:            case 'U':
       31:  575:                udp_port = atoi(optarg);
       31:  576:                break;
        3:  577:            case 's':
        3:  578:                uds_stream_path = optarg;
        3:  579:                break;
        3:  580:            case 'd':
        3:  581:                uds_dgram_path = optarg;
        3:  582:                break;
       14:  583:            case 'f':
       14:  584:                save_file_path = optarg;
       14:  585:                break;
        2:  586:            default:
        2:  587:                fprintf(stderr,
        -:  588:                    "Usage: %s -c <carbon> -o <oxygen> -h <hydrogen> "
        -:  589:                    "[-t <timeout>] -T <tcp_port> -U <udp_port> \\\n"
        -:  590:                    "       [-s <uds_stream_path>] [-d <uds_dgram_path>] -f <file path>\n"
        -:  591:                    " -f <file path>",
        -:  592:                    argv[0]);
        2:  593:                exit(EXIT_FAILURE);
        -:  594:        }
        -:  595:    }
        -:  596:
        -:  597:    // Enforce: −c, −o, −h, −T, −U are all mandatory.
       31:  598:    if (tcp_port <= 0 || udp_port <= 0)
        -:  599:    {
        3:  600:        fprintf(stderr,
        -:  601:            "ERROR: you must specify "
        -:  602:            "-T <tcp_port> -U <udp_port>.\n"
        -:  603:            "Usage: %s -c <carbon> -o <oxygen> -h <hydrogen> "
        -:  604:            "[-t <timeout>] -T <tcp_port> -U <udp_port> \\\n"
        -:  605:            "       [-s <uds_stream_path>] [-d <uds_dgram_path>]  -f <file path>\n",
        -:  606:            argv[0]);
        3:  607:        exit(EXIT_FAILURE);
        -:  608:    }
        -:  609:
        -:  610:    // if we did use the f flag
       28:  611:    if (save_file_path) {
       14:  612:        load_atoms_from_file(save_file_path, init_carbon, init_oxygen, init_hydrogen);
        -:  613:    }
        -:  614:    else {
        -:  615:        // אם אין -f, מאתחלים inv לערכי ברירת המחדל
       14:  616:        atom_stock.carbon         = init_carbon;
       14:  617:        atom_stock.oxygen         = init_oxygen;
       14:  618:        atom_stock.hydrogen       = init_hydrogen;
        -:  619:    }
        -:  620:
        -:  621:    // 3) If timeout_secs > 0, install SIGALRM handler and call alarm(timeout_secs)
       28:  622:    if (timeout_secs > 0) {
        -:  623:        struct sigaction sa_alrm;
        2:  624:        memset(&sa_alrm, 0, sizeof(sa_alrm));
        2:  625:        sa_alrm.sa_handler = alarm_handler;
        2:  626:        sigemptyset(&sa_alrm.sa_mask);
        2:  627:        sa_alrm.sa_flags = 0;  // not using SA_RESTART
        2:  628:        if (sigaction(SIGALRM, &sa_alrm, NULL) == -1) {
    #####:  629:            perror("sigaction(SIGALRM)");
    #####:  630:            exit(EXIT_FAILURE);
        -:  631:        }
        2:  632:        alarm(timeout_secs);
        -:  633:    }
        -:  634:
        -:  635:    // Convert ports to strings for getaddrinfo
        -:  636:    char tcp_port_str[6], udp_port_str[6];
       28:  637:    snprintf(tcp_port_str, sizeof(tcp_port_str), "%d", tcp_port);
       28:  638:    snprintf(udp_port_str, sizeof(udp_port_str), "%d", udp_port);
        -:  639:
        -:  640:    // ----------------------------------------------------------------------------
        -:  641:    // 4) Create TCP listening socket on tcp_port
        -:  642:    // ----------------------------------------------------------------------------
        -:  643:    int tcp_listen_fd;
        -:  644:    {
        -:  645:        struct addrinfo hints_tcp;
        -:  646:        struct addrinfo *servinfo_tcp, *p_tcp;
       28:  647:        memset(&hints_tcp, 0, sizeof(hints_tcp));
       28:  648:        hints_tcp.ai_family   = AF_INET;      // IPv4 only (for simplicity)
       28:  649:        hints_tcp.ai_socktype = SOCK_STREAM;  // TCP
       28:  650:        hints_tcp.ai_flags    = AI_PASSIVE;   // use local IP
        -:  651:
        -:  652:        int rv;
       28:  653:        if ((rv = getaddrinfo(NULL, tcp_port_str, &hints_tcp, &servinfo_tcp)) != 0) {
    #####:  654:            fprintf(stderr, "getaddrinfo (TCP): %s\n", gai_strerror(rv));
    #####:  655:            exit(EXIT_FAILURE);
        -:  656:        }
        -:  657:
       28:  658:        int yes = 1;
      28*:  659:        for (p_tcp = servinfo_tcp; p_tcp != NULL; p_tcp = p_tcp->ai_next) {
       28:  660:            tcp_listen_fd = socket(p_tcp->ai_family, p_tcp->ai_socktype, p_tcp->ai_protocol);
      28*:  661:            if (tcp_listen_fd < 0) {
    #####:  662:                perror("socket (TCP)");
    #####:  663:                continue;
        -:  664:            }
       28:  665:            if (setsockopt(tcp_listen_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1) {
    #####:  666:                perror("setsockopt (TCP)");
    #####:  667:                close(tcp_listen_fd);
    #####:  668:                exit(EXIT_FAILURE);
        -:  669:            }
      28*:  670:            if (bind(tcp_listen_fd, p_tcp->ai_addr, p_tcp->ai_addrlen) < 0) {
    #####:  671:                perror("bind (TCP)");
    #####:  672:                close(tcp_listen_fd);
    #####:  673:                continue;
        -:  674:            }
        -:  675:            // Bound successfully
       28:  676:            break;
        -:  677:        }
       28:  678:        if (p_tcp == NULL) {
    #####:  679:            fprintf(stderr, "Error: failed to bind TCP on port %s\n", tcp_port_str);
    #####:  680:            exit(EXIT_FAILURE);
        -:  681:        }
       28:  682:        freeaddrinfo(servinfo_tcp);
        -:  683:
       28:  684:        if (listen(tcp_listen_fd, BACKLOG) < 0) {
    #####:  685:            perror("listen (TCP)");
    #####:  686:            exit(EXIT_FAILURE);
        -:  687:        }
       28:  688:        printf("server (TCP): listening on port %s...\n", tcp_port_str);
        -:  689:
        -:  690:    }
        -:  691:
        -:  692:    // ----------------------------------------------------------------------------
        -:  693:    // 5) Create UDP socket on udp_port
        -:  694:    // ----------------------------------------------------------------------------
        -:  695:    int udp_fd;
        -:  696:    {
        -:  697:        struct addrinfo hints_udp;
        -:  698:        struct addrinfo *servinfo_udp, *p_udp;
       28:  699:        memset(&hints_udp, 0, sizeof(hints_udp));
       28:  700:        hints_udp.ai_family   = AF_INET;      // IPv4 only
       28:  701:        hints_udp.ai_socktype = SOCK_DGRAM;   // UDP
       28:  702:        hints_udp.ai_flags    = AI_PASSIVE;   // use local IP
        -:  703:
        -:  704:        int rv2;
       28:  705:        if ((rv2 = getaddrinfo(NULL, udp_port_str, &hints_udp, &servinfo_udp)) != 0) {
    #####:  706:            fprintf(stderr, "getaddrinfo (UDP): %s\n", gai_strerror(rv2));
    #####:  707:            exit(EXIT_FAILURE);
        -:  708:        }
      28*:  709:        for (p_udp = servinfo_udp; p_udp != NULL; p_udp = p_udp->ai_next) {
       28:  710:            udp_fd = socket(p_udp->ai_family, p_udp->ai_socktype, p_udp->ai_protocol);
      28*:  711:            if (udp_fd < 0) {
    #####:  712:                perror("socket (UDP)");
    #####:  713:                continue;
        -:  714:            }
      28*:  715:            if (bind(udp_fd, p_udp->ai_addr, p_udp->ai_addrlen) < 0) {
    #####:  716:                perror("bind (UDP)");
    #####:  717:                close(udp_fd);
    #####:  718:                continue;
        -:  719:            }
        -:  720:            // Bound successfully
       28:  721:            break;
        -:  722:        }
       28:  723:        if (p_udp == NULL) {
    #####:  724:            fprintf(stderr, "Error: failed to bind UDP on port %s\n", udp_port_str);
    #####:  725:            exit(EXIT_FAILURE);
        -:  726:        }
       28:  727:        freeaddrinfo(servinfo_udp);
        -:  728:
       28:  729:        printf("server (UDP): listening on port %s...\n", udp_port_str);
        -:  730:    }
        -:  731:
        -:  732:    // ----------------------------------------------------------------------------
        -:  733:    // 6) create UDS‐STREAM socket "-s"
        -:  734:    // ----------------------------------------------------------------------------
       28:  735:    int uds_stream_fd = -1;
       28:  736:    if (uds_stream_path) {
        -:  737:        // Remove any existing file at that path, to avoid “address already in use”
        3:  738:        unlink(uds_stream_path);
        -:  739:
        3:  740:        uds_stream_fd = socket(AF_UNIX, SOCK_STREAM, 0);
        3:  741:        if (uds_stream_fd < 0) {
    #####:  742:            perror("socket (UDS_STREAM)");
    #####:  743:            exit(EXIT_FAILURE);
        -:  744:        }
        -:  745:        struct sockaddr_un uds_stream_addr;
        3:  746:        memset(&uds_stream_addr, 0, sizeof(uds_stream_addr));
        3:  747:        uds_stream_addr.sun_family = AF_UNIX;
        3:  748:        strncpy(uds_stream_addr.sun_path, uds_stream_path,
        -:  749:                sizeof(uds_stream_addr.sun_path) - 1);
        -:  750:
        3:  751:        if (bind(uds_stream_fd, (struct sockaddr*)&uds_stream_addr,
        -:  752:                 sizeof(uds_stream_addr)) < 0)
        -:  753:        {
    #####:  754:            perror("bind (UDS_STREAM)");
    #####:  755:            close(uds_stream_fd);
    #####:  756:            exit(EXIT_FAILURE);
        -:  757:        }
        3:  758:        if (listen(uds_stream_fd, BACKLOG) < 0) {
    #####:  759:            perror("listen (UDS_STREAM)");
    #####:  760:            close(uds_stream_fd);
    #####:  761:            exit(EXIT_FAILURE);
        -:  762:        }
        3:  763:        printf("server (UDS_STREAM): listening on path %s\n", uds_stream_path);
        -:  764:    }
        -:  765:
        -:  766:    // ----------------------------------------------------------------------------
        -:  767:    // 7) create UDS‐DGRAM socket "-d"
        -:  768:    // ----------------------------------------------------------------------------
       28:  769:    int uds_dgram_fd = -1;
       28:  770:    if (uds_dgram_path) {
        3:  771:        unlink(uds_dgram_path);
        -:  772:
        3:  773:        uds_dgram_fd = socket(AF_UNIX, SOCK_DGRAM, 0);
        3:  774:        if (uds_dgram_fd < 0) {
    #####:  775:            perror("socket (UDS_DGRAM)");
    #####:  776:            exit(EXIT_FAILURE);
        -:  777:        }
        -:  778:        struct sockaddr_un uds_dgram_addr;
        3:  779:        memset(&uds_dgram_addr, 0, sizeof(uds_dgram_addr));
        3:  780:        uds_dgram_addr.sun_family = AF_UNIX;
        3:  781:        strncpy(uds_dgram_addr.sun_path, uds_dgram_path,
        -:  782:                sizeof(uds_dgram_addr.sun_path) - 1);
        -:  783:
        3:  784:        if (bind(uds_dgram_fd, (struct sockaddr*)&uds_dgram_addr,
        -:  785:                 sizeof(uds_dgram_addr)) < 0)
        -:  786:        {
    #####:  787:            perror("bind (UDS_DGRAM)");
    #####:  788:            close(uds_dgram_fd);
    #####:  789:            exit(EXIT_FAILURE);
        -:  790:        }
        3:  791:        printf("server (UDS_DGRAM): bound on path %s\n", uds_dgram_path);
        -:  792:    }
        -:  793:
        -:  794:    // ----------------------------------------------------------------------------
        -:  795:    // 8) Initialize an array of active TCP client fds
        -:  796:    // ----------------------------------------------------------------------------
        -:  797:    int client_fds[MAX_CLIENTS];
    28700:  798:    for (int i = 0; i < MAX_CLIENTS; i++) {
    28672:  799:        client_fds[i] = -1;  // –1 means “empty slot”
        -:  800:    }
        -:  801:
        -:  802:    // ----------------------------------------------------------------------------
        -:  803:    // 9) Print the console prompt and initial inventory
        -:  804:    // ----------------------------------------------------------------------------
       28:  805:    printf("\n=== DRINKS_BAR SERVER READY ===\n");
       28:  806:    printf("Valid console commands (type here):\n");
       28:  807:    printf("  GEN SOFT DRINK\n");
       28:  808:    printf("  GEN VODKA\n");
       28:  809:    printf("  GEN CHAMPAGNE\n\n");
       28:  810:    printf("Press Ctrl+C to terminate.\n\n");
       28:  811:    print_inventory();
        -:  812:
        -:  813:    // ----------------------------------------------------------------------------
        -:  814:    // 10) Enter the main select() loop
        -:  815:    // ----------------------------------------------------------------------------
       85:  816:    while (1) {
      113:  817:        if (timed_out) {
        -:  818:            // Timeout triggered ⇒ no activity within the last <timeout_secs> seconds
        2:  819:            printf("TIMEOUT: no activity for %d seconds. Shutting down.\n", timeout_secs);
        2:  820:            break;
        -:  821:        }
        -:  822:
        -:  823:        fd_set read_fds;
     1887:  824:        FD_ZERO(&read_fds);
      111:  825:        int max_fd = -1;
        -:  826:
        -:  827:        // a) Always watch tcp_listen_fd
      111:  828:        FD_SET(tcp_listen_fd, &read_fds);
      111:  829:        if (tcp_listen_fd > max_fd) max_fd = tcp_listen_fd;
        -:  830:
        -:  831:        // b) Always watch udp_fd
      111:  832:        FD_SET(udp_fd, &read_fds);
      111:  833:        if (udp_fd > max_fd) max_fd = udp_fd;
        -:  834:
        -:  835:        // c) Watch all active TCP client fds
   113775:  836:        for (int i = 0; i < MAX_CLIENTS; i++) {
   113664:  837:            if (client_fds[i] != -1) {
       28:  838:                FD_SET(client_fds[i], &read_fds);
       28:  839:                if (client_fds[i] > max_fd) {
       28:  840:                    max_fd = client_fds[i];
        -:  841:                }
        -:  842:            }
        -:  843:        }
        -:  844:
        -:  845:        // d) Watch keyboard (STDIN_FILENO)
      111:  846:        FD_SET(STDIN_FILENO, &read_fds);
     111*:  847:        if (STDIN_FILENO > max_fd) max_fd = STDIN_FILENO;
        -:  848:
        -:  849:        // e) If UDS_STREAM was created, watch uds_stream_fd
      111:  850:        if (uds_stream_path) {
        6:  851:            FD_SET(uds_stream_fd, &read_fds);
        6:  852:            if (uds_stream_fd > max_fd) max_fd = uds_stream_fd;
        -:  853:        }
        -:  854:
        -:  855:        // f) If UDS_DGRAM was created, watch uds_dgram_fd
      111:  856:        if (uds_dgram_path) {
        6:  857:            FD_SET(uds_dgram_fd, &read_fds);
        6:  858:            if (uds_dgram_fd > max_fd) max_fd = uds_dgram_fd;
        -:  859:        }
        -:  860:
        -:  861:        // Wait until at least one descriptor is ready
      111:  862:        int ready = select(max_fd + 1, &read_fds, NULL, NULL, NULL);
      111:  863:        if (ready < 0) {
        2:  864:            if (errno == EINTR) {
        -:  865:                // Interrupted by a signal (likely SIGALRM). Recompute if timed_out.
        2:  866:                continue;
        -:  867:            }
    #####:  868:            perror("select");
    #####:  869:            exit(EXIT_FAILURE);
        -:  870:        }
        -:  871:
        -:  872:        // -------------------------------------------------------
        -:  873:        // 10.1 New incoming TCP connection?
        -:  874:        // If tcp_listen_fd is ready, accept() it and store in client_fds[].
        -:  875:        // -------------------------------------------------------
      109:  876:        if (FD_ISSET(tcp_listen_fd, &read_fds)) {
        -:  877:            struct sockaddr_storage client_addr;
       14:  878:            socklen_t addr_len = sizeof(client_addr);
       14:  879:            int new_fd = accept(tcp_listen_fd,
        -:  880:                                (struct sockaddr*)&client_addr,
        -:  881:                                &addr_len);
       14:  882:            if (new_fd < 0) {
    #####:  883:                perror("accept (TCP)");
        -:  884:            } else {
        -:  885:                // store new_fd in the first empty slot
       14:  886:                bool added = false;
      14*:  887:                for (int i = 0; i < MAX_CLIENTS; i++) {
       14:  888:                    if (client_fds[i] == -1) {
       14:  889:                        client_fds[i] = new_fd;
       14:  890:                        added = true;
       14:  891:                        break;
        -:  892:                    }
        -:  893:                }
       14:  894:                if (!added) {
        -:  895:                    // too many clients; drop this connection
    #####:  896:                    close(new_fd);
        -:  897:                } else {
        -:  898:                    // print the new client's IPv4 address
        -:  899:                    char ipstr[INET_ADDRSTRLEN];
       14:  900:                    struct sockaddr_in *sa = (struct sockaddr_in *)&client_addr;
       14:  901:                    inet_ntop(AF_INET, &sa->sin_addr, ipstr, sizeof(ipstr));
       14:  902:                    printf("New TCP client from %s\n", ipstr);
        -:  903:                }
        -:  904:            }
        -:  905:            // Reset alarm if using timeout
       14:  906:            if (timeout_secs > 0) {
        1:  907:                alarm(timeout_secs);
        1:  908:                timed_out = 0;
        -:  909:            }
        -:  910:        }
        -:  911:
        -:  912:        // -------------------------------------------------------
        -:  913:        // 10.2 Incoming UDP datagram?
        -:  914:        // If udp_fd is ready, recvfrom() it, parse_and_update_udp(), sendto() the reply.
        -:  915:        // -------------------------------------------------------
      109:  916:        if (FD_ISSET(udp_fd, &read_fds)) {
        -:  917:            char buf[MAXBUF];
        -:  918:            struct sockaddr_storage client_addr;
       30:  919:            socklen_t addr_len = sizeof(client_addr);
       30:  920:            ssize_t numbytes = recvfrom(
        -:  921:                udp_fd,
        -:  922:                buf, sizeof(buf)-1,
        -:  923:                0,
        -:  924:                (struct sockaddr*)&client_addr,
        -:  925:                &addr_len
        -:  926:            );
       30:  927:            if (numbytes < 0) {
    #####:  928:                perror("recvfrom (UDP)");
        -:  929:            } else {
       30:  930:                buf[numbytes] = '\0';
        -:  931:                char response[MAXBUF];
       30:  932:                parse_and_update_udp(buf, response, sizeof(response));
        -:  933:                // reply to exactly that client address:
       30:  934:                if (sendto(
        -:  935:                        udp_fd,
        -:  936:                        response, strlen(response),
        -:  937:                        0,
        -:  938:                        (struct sockaddr*)&client_addr,
        -:  939:                        addr_len
        -:  940:                    ) < 0)
        -:  941:                {
    #####:  942:                    perror("sendto (UDP)");
        -:  943:                }
        -:  944:            }
       30:  945:            if (timeout_secs > 0) {
    #####:  946:                alarm(timeout_secs);
    #####:  947:                timed_out = 0;
        -:  948:            }
        -:  949:        }
        -:  950:
        -:  951:        // -------------------------------------------------------
        -:  952:        // 10.3 Check each active TCP client descriptor: 
        -:  953:        // if ready, call handle_tcp_client(); if it returns false, close & remove.
        -:  954:        // -------------------------------------------------------
   111725:  955:        for (int i = 0; i < MAX_CLIENTS; i++) {
   111616:  956:            int fd = client_fds[i];
   111616:  957:            if (fd != -1 && FD_ISSET(fd, &read_fds)) {
       28:  958:                if (!handle_tcp_client(fd)) {
       14:  959:                    close(fd);
       14:  960:                    client_fds[i] = -1;
        -:  961:                }
        -:  962:                // Reset alarm if using timeout
       28:  963:                if (timeout_secs > 0) {
        2:  964:                    alarm(timeout_secs);
        2:  965:                    timed_out = 0;
        -:  966:                }
        -:  967:            }
        -:  968:        }
        -:  969:
        -:  970:        // -------------------------------------------------------
        -:  971:        // 10.4 Console keyboard input (STDIN_FILENO)?
        -:  972:        // If ready, read one line, interpret “GEN …” commands.
        -:  973:        // -------------------------------------------------------
      109:  974:        if (FD_ISSET(STDIN_FILENO, &read_fds)) {
       34:  975:            if (save_file_path) {
       12:  976:                load_atoms_from_file(save_file_path, 0, 0, 0);
        -:  977:            }
        -:  978:            char linebuf[MAXBUF];
       34:  979:            if (fgets(linebuf, sizeof(linebuf), stdin) != NULL) {
        -:  980:                // strip trailing newline
        8:  981:                size_t L = strlen(linebuf);
        8:  982:                if (L > 0 && linebuf[L-1] == '\n') {
        8:  983:                    linebuf[L-1] = '\0';
        -:  984:                }
        -:  985:                // Expect “GEN <BEVERAGE>”
        8:  986:                char *cmd = strtok(linebuf, " \t");
        8:  987:                if (!cmd || strcmp(cmd, "GEN") != 0) {
        1:  988:                    printf("ERROR: invalid console command\n");
        -:  989:                } else {
        7:  990:                    char *drink = strtok(NULL, " \t");
        7:  991:                    if (!drink) {
        1:  992:                        printf("ERROR: missing drink type after GEN\n");
        -:  993:                    }
        6:  994:                    else if (strcmp(drink, "SOFT") == 0) {
        3:  995:                        char *maybe_drink = strtok(NULL, " \t");
        3:  996:                        if (!maybe_drink || strcmp(maybe_drink, "DRINK") != 0) {
        1:  997:                            printf("ERROR: did you mean 'GEN SOFT DRINK'?\n");
        -:  998:                        } else {
        -:  999:                            // Soft drink requires 6 C, 14 H, 9 O
        2: 1000:                            uint64_t c = atom_stock.carbon / 6;
        2: 1001:                            uint64_t h = atom_stock.hydrogen / 14;
        2: 1002:                            uint64_t o = atom_stock.oxygen / 9;
        2: 1003:                            uint64_t can_make = c;
       2*: 1004:                            if (h < can_make) can_make = h;
        2: 1005:                            if (o < can_make) can_make = o;
        2: 1006:                            printf("You can make up to %llu SOFT DRINK(s)\n",
        -: 1007:                                   (unsigned long long)can_make);
        -: 1008:                        }
        -: 1009:                    }
        3: 1010:                    else if (strcmp(drink, "VODKA") == 0) {
        -: 1011:                        // Vodka requires 8 C, 20 H, 8 O
        1: 1012:                        uint64_t c = atom_stock.carbon / 8;
        1: 1013:                        uint64_t h = atom_stock.hydrogen / 20;
        1: 1014:                        uint64_t o = atom_stock.oxygen / 8;
        1: 1015:                        uint64_t can_make = c;
       1*: 1016:                        if (h < can_make) can_make = h;
       1*: 1017:                        if (o < can_make) can_make = o;
        1: 1018:                        printf("You can make up to %llu VODKA(s)\n",
        -: 1019:                               (unsigned long long)can_make);
        -: 1020:                    }
        2: 1021:                    else if (strcmp(drink, "CHAMPAGNE") == 0) {
        -: 1022:                        // Champagne requires 3 C, 9 H, 4 O
        1: 1023:                        uint64_t c = atom_stock.carbon / 3;
        1: 1024:                        uint64_t h = atom_stock.hydrogen / 9;
        1: 1025:                        uint64_t o = atom_stock.oxygen / 4;
        1: 1026:                        uint64_t can_make = c;
       1*: 1027:                        if (h < can_make) can_make = h;
        1: 1028:                        if (o < can_make) can_make = o;
        1: 1029:                        printf("You can make up to %llu CHAMPAGNE(s)\n",
        -: 1030:                               (unsigned long long)can_make);
        -: 1031:                    }
        -: 1032:                    else {
        1: 1033:                        printf("ERROR: unknown drink type '%s'\n", drink);
        -: 1034:                    }
        -: 1035:                }
        -: 1036:            } else {
        -: 1037:                // EOF (Ctrl+D) or error reading stdin ⇒ exit loop
       26: 1038:                printf("Console closed or error – exiting.\n");
       26: 1039:                break;
        -: 1040:            }
        8: 1041:            if (timeout_secs > 0) {
    #####: 1042:                alarm(timeout_secs);
    #####: 1043:                timed_out = 0;
        -: 1044:            }
        -: 1045:        }
        -: 1046:
        -: 1047:        // -------------------------------------------------------
        -: 1048:        // 10.5 Accept a new UDS_STREAM connection (if that socket exists)
        -: 1049:        // Once accepted, handle exactly one “ADD …” on that connection and close.
        -: 1050:        // -------------------------------------------------------
       83: 1051:        if (uds_stream_path && uds_stream_fd >= 0 && FD_ISSET(uds_stream_fd, &read_fds)) {
        1: 1052:            int new_un_fd = accept(uds_stream_fd, NULL, NULL);
        1: 1053:            if (new_un_fd < 0) {
    #####: 1054:                perror("accept (UDS_STREAM)");
        -: 1055:            } else {
        1: 1056:                if (save_file_path) {
        1: 1057:                    load_atoms_from_file(save_file_path, 0,0,0);
        -: 1058:                }
        -: 1059:                // Use the same TCP‐handler for “ADD …” lines
        1: 1060:                if (!handle_tcp_client(new_un_fd)) {
        -: 1061:                    // either closed immediately or error
        -: 1062:                }
        1: 1063:                close(new_un_fd);
        -: 1064:            }
        1: 1065:            if (timeout_secs > 0) {
    #####: 1066:                alarm(timeout_secs);
    #####: 1067:                timed_out = 0;
        -: 1068:            }
        -: 1069:        }
        -: 1070:
        -: 1071:        // -------------------------------------------------------
        -: 1072:        // 10.6 Receive one UDS_DGRAM datagram “DELIVER …” (if that socket exists)
        -: 1073:        // Parse & respond to that client’s address over UDS datagram.
        -: 1074:        // -------------------------------------------------------
       83: 1075:        if (uds_dgram_path && uds_dgram_fd >= 0 && FD_ISSET(uds_dgram_fd, &read_fds)) {
        -: 1076:            char buf[MAXBUF];
        -: 1077:            struct sockaddr_un cli_un;
        2: 1078:            socklen_t cli_len = sizeof(cli_un);
        2: 1079:            ssize_t nbytes = recvfrom(
        -: 1080:                uds_dgram_fd,
        -: 1081:                buf, sizeof(buf)-1,
        -: 1082:                0,
        -: 1083:                (struct sockaddr*)&cli_un,
        -: 1084:                &cli_len
        -: 1085:            );
        2: 1086:            if (nbytes < 0) {
    #####: 1087:                perror("recvfrom (UDS_DGRAM)");
        -: 1088:            } else {
        2: 1089:                buf[nbytes] = '\0';
        2: 1090:                if (save_file_path) {
        2: 1091:                    load_atoms_from_file(save_file_path, 0,0,0);
        -: 1092:                }
        -: 1093:                char response[MAXBUF];
        2: 1094:                parse_and_update_udp(buf, response, sizeof(response));
        2: 1095:                if (save_file_path) {
        2: 1096:                    save_atoms_to_file(save_file_path);
        -: 1097:                }
        2: 1098:                if (sendto(
        -: 1099:                        uds_dgram_fd,
        -: 1100:                        response, strlen(response),
        -: 1101:                        0,
        -: 1102:                        (struct sockaddr*)&cli_un,
        -: 1103:                        cli_len
        -: 1104:                    ) < 0)
        -: 1105:                {
    #####: 1106:                    perror("sendto (UDS_DGRAM)");
        -: 1107:                }
        -: 1108:            }
        2: 1109:            if (timeout_secs > 0) {
    #####: 1110:                alarm(timeout_secs);
    #####: 1111:                timed_out = 0;
        -: 1112:            }
        -: 1113:        }
        -: 1114:
        -: 1115:    } // end of main select‐loop
        -: 1116:
        -: 1117:    // ----------------------------------------------------------------------------
        -: 1118:    // 11) Clean up: close sockets and unlink any UDS files
        -: 1119:    // ----------------------------------------------------------------------------
       28: 1120:    if (tcp_listen_fd >= 0) close(tcp_listen_fd);
       28: 1121:    if (udp_fd >= 0)        close(udp_fd);
       28: 1122:    if (uds_stream_fd >= 0) close(uds_stream_fd);
       28: 1123:    if (uds_dgram_fd >= 0)  close(uds_dgram_fd);
        -: 1124:
       28: 1125:    if (uds_stream_path)   unlink(uds_stream_path);
       28: 1126:    if (uds_dgram_path)    unlink(uds_dgram_path);
        -: 1127:
       28: 1128:    printf("Server exiting cleanly.\n");
       28: 1129:    return 0;
        -: 1130:}
