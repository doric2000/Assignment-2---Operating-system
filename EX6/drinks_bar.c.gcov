        -:    0:Source:drinks_bar.c
        -:    0:Graph:drinks_bar.gcno
        -:    0:Data:drinks_bar.gcda
        -:    0:Runs:26
        -:    1:/*
        -:    2:** drinks_bar.c -- a combined TCP+UDP server for:
        -:    3:**   • TCP ADD CARBON / ADD OXYGEN / ADD HYDROGEN (Stage 1)
        -:    4:**   • UDP DELIVER WATER / CARBON DIOXIDE / GLUCOSE / ALCOHOL (Stage 2)
        -:    5:**   • console commands to tell how many beverages (SOFT DRINK, VODKA, CHAMPAGNE) can be made (Stage 3)
        -:    6:**   • optionally also accept UDS‐STREAM (‐s) or UDS‐DGRAM (‐d) like UDP/TCP
        -:    7:**
        -:    8:** Mandatory flags: 
        -:    9:**   -c <initial_carbon> 
        -:   10:**   -o <initial_oxygen> 
        -:   11:**   -h <initial_hydrogen>
        -:   12:**   -T <tcp_port> 
        -:   13:**   -U <udp_port>
        -:   14:**
        -:   15:** Optional: 
        -:   16:**   -t <timeout_seconds>
        -:   17:**   -s <uds_stream_path>   (if you want a Unix‐domain STREAM socket in addition to TCP+UDP)
        -:   18:**   -d <uds_dgram_path>    (if you want a Unix‐domain DGRAM socket in addition to TCP+UDP)
        -:   19:**
        -:   20:** Examples:
        -:   21:**   ./drinks_bar -c 100 -o 50 -h 200 -T 5555 -U 6666
        -:   22:**     (only TCP on 5555 and UDP on 6666)
        -:   23:**
        -:   24:**   ./drinks_bar -c 10 -o 10 -h 10 -T 5555 -U 6666 -s /tmp/my_stream.sock
        -:   25:**     (TCP/UDP plus a UDS-STREAM socket at /tmp/my_stream.sock)
        -:   26:**
        -:   27:**   ./drinks_bar -c 10 -o 10 -h 10 -T 5555 -U 6666 -d /tmp/my_dgram.sock
        -:   28:**     (TCP/UDP plus a UDS-DGRAM socket at /tmp/my_dgram.sock)
        -:   29:**
        -:   30:*/
        -:   31:
        -:   32:#include <stdio.h>           // printf, fprintf, perror
        -:   33:#include <stdlib.h>          // exit, malloc, free
        -:   34:#include <string.h>          // strlen, strcmp, strtok_r, strncpy, snprintf, memset, memcpy
        -:   35:#include <stdint.h>          // uint64_t
        -:   36:#include <stdbool.h>         // bool, true, false
        -:   37:#include <unistd.h>          // close, fork, write, unlink, STDIN_FILENO
        -:   38:#include <errno.h>           // errno
        -:   39:#include <sys/types.h>       // socklen_t
        -:   40:#include <sys/socket.h>      // socket, bind, listen, accept, send, recv, sendto, recvfrom
        -:   41:#include <sys/un.h>          // sockaddr_un
        -:   42:#include <netdb.h>           // getaddrinfo, freeaddrinfo, struct addrinfo
        -:   43:#include <arpa/inet.h>       // inet_ntop
        -:   44:#include <netinet/in.h>      // sockaddr_in, sockaddr_in6
        -:   45:#include <sys/select.h>      // select, fd_set, FD_ZERO, FD_SET, FD_ISSET
        -:   46:#include <sys/wait.h>        // waitpid, WNOHANG
        -:   47:#include <signal.h>          // sigaction, SIGCHLD, SIGALRM
        -:   48:#include <getopt.h>          // getopt_long
        -:   49:#include <stddef.h>          // offsetof
        -:   50:#include <sys/file.h>   // flock
        -:   51:#include <fcntl.h>
        -:   52:#include <sys/stat.h>
        -:   53:
        -:   54:#define MAX_ATOMS  ((uint64_t)1000000000000000000ULL)  // 10^18 maximum quantity
        -:   55:#define BACKLOG    10                                   // TCP listen backlog
        -:   56:#define MAX_CLIENTS FD_SETSIZE                           // max simultaneous TCP clients
        -:   57:#define MAXBUF     1024                                  // buffer size for recv/send
        -:   58:
        -:   59:// ----------------------------------------------------------------------------
        -:   60:// Struct to store counts of each atom type (Stage 1)
        -:   61:// ----------------------------------------------------------------------------
        -:   62:typedef struct {
        -:   63:    uint64_t carbon;    // count of carbon atoms
        -:   64:    uint64_t oxygen;    // count of oxygen atoms
        -:   65:    uint64_t hydrogen;  // count of hydrogen atoms
        -:   66:} AtomStock;
        -:   67:
        -:   68:
        -:   69:// Global atomic stock (initialized via flags -c, -o, -h)
        -:   70:static AtomStock atom_stock = { 0, 0, 0 };
        -:   71:
        -:   72:// A simple flag set by SIGALRM to signal “timeout” (Stage 4)
        -:   73:static volatile sig_atomic_t timed_out = 0;
        -:   74:
        -:   75://if we will have -f flag than we will save here the path of the file to load/save the atoms from.
        -:   76:static char *save_file_path = NULL;
        -:   77:
        -:   78:// ----------------------------------------------------------------------------
        -:   79:// Prototypes
        -:   80:// ----------------------------------------------------------------------------
        -:   81:
        -:   82:// SIGCHLD handler: reap any zombie children
        -:   83:void sigchld_handler(int sig);
        -:   84:
        -:   85:// SIGALRM handler: mark that timeout occurred
        -:   86:void alarm_handler(int sig);
        -:   87:
        -:   88:// Get the “address field” portion (IPv4 or IPv6) from sockaddr*
        -:   89:void *get_in_addr(struct sockaddr *sa);
        -:   90:
        -:   91:// Print the current stock of atoms to stdout
        -:   92:void print_inventory(void);
        -:   93:
        -:   94:// Handle exactly one TCP client command on `client_fd` (an “ADD …” line).
        -:   95:// - Reads one line, parses “ADD <TYPE> <NUM>\n”
        -:   96:// - Updates atom_stock
        -:   97:// - Sends back either “OK: Carbon=… Oxygen=… Hydrogen=…\n” or “ERROR: …\n”
        -:   98:// Returns false if the client closed connection or a read‐error occurred.
        -:   99:bool handle_tcp_client(int client_fd);
        -:  100:
        -:  101:// Parse a single “ADD <TYPE> <NUM>” line (no trailing newline), update atom_stock.
        -:  102:// Fill `response` with either
        -:  103://   “OK: Carbon=.. Oxygen=.. Hydrogen=..\n”
        -:  104:// or “ERROR: ...\n”
        -:  105:void parse_and_update_tcp(const char *line, char *response, size_t resp_size);
        -:  106:
        -:  107:// Parse a single “DELIVER <MOLECULE> <NUM>” line, check atom stock,
        -:  108:// subtract required atoms if possible, and fill `response` with
        -:  109://   “OK: Atoms left – Carbon=.. Oxygen=.. Hydrogen=..\n”
        -:  110:// or “ERROR: ...\n”
        -:  111:void parse_and_update_udp(const char *line, char *response, size_t resp_size);
        -:  112:
        -:  113://if the file exists and big enough , reads sizeof (atomStock) to the global var.
        -:  114://else creating a new file , fills it with the values of the atoms and read the full struct to the file.
        -:  115:static void load_atoms_from_file(const char *path, uint64_t init_c,uint64_t init_o,uint64_t init_h);
        -:  116:
        -:  117:
        -:  118://opens / creates the file in rb or wb. locks the file with flock to prevent parallel changes.
        -:  119://writes a block of our atoms struct with fwrite.
        -:  120://releases the lock and closes the files.
        -:  121:static void save_atoms_to_file(const char *path);
        -:  122:
        -:  123:
        -:  124:// ----------------------------------------------------------------------------
        -:  125:// SIGCHLD handler: simply reap all children in a loop (non‐blocking).
        -:  126:// ----------------------------------------------------------------------------
    #####:  127:void sigchld_handler(int sig) {
        -:  128:    (void)sig;  // suppress unused‐parameter warning
    #####:  129:    int saved_errno = errno;
    #####:  130:    while (waitpid(-1, NULL, WNOHANG) > 0) { }
    #####:  131:    errno = saved_errno;
    #####:  132:}
        -:  133:
        -:  134:// ----------------------------------------------------------------------------
        -:  135:// SIGALRM handler: marks that we timed out (no activity for <timeout> seconds).
        -:  136:// We use write() (async‐signal safe) just to print a quick message.
        -:  137:// ----------------------------------------------------------------------------
        1:  138:void alarm_handler(int sig) {
        -:  139:    (void)sig;
        1:  140:    const char msg[] = ">>> Alarm handler invoked! Server shutting down due to inactivity.\n";
        1:  141:    write(STDOUT_FILENO, msg, sizeof(msg) - 1);
        1:  142:    timed_out = 1;
        1:  143:}
        -:  144:
        -:  145:// ----------------------------------------------------------------------------
        -:  146:// Return pointer to the IPv4 or IPv6 address inside a sockaddr.
        -:  147:// ----------------------------------------------------------------------------
    #####:  148:void *get_in_addr(struct sockaddr *sa) {
    #####:  149:    if (sa->sa_family == AF_INET) {
    #####:  150:        return &(((struct sockaddr_in*)sa)->sin_addr);
        -:  151:    }
    #####:  152:    return &(((struct sockaddr_in6*)sa)->sin6_addr);
        -:  153:}
        -:  154:
        -:  155:// ----------------------------------------------------------------------------
        -:  156:// Print the current atom inventory on stdout.
        -:  157:// ----------------------------------------------------------------------------
       22:  158:void print_inventory(void) {
       22:  159:    printf("SERVER INVENTORY (atoms): Carbon=%llu  Oxygen=%llu  Hydrogen=%llu\n",
       22:  160:           (unsigned long long)atom_stock.carbon,
       22:  161:           (unsigned long long)atom_stock.oxygen,
       22:  162:           (unsigned long long)atom_stock.hydrogen);
       22:  163:}
        -:  164:
        -:  165:// ----------------------------------------------------------------------------
        -:  166:// Parse and update a TCP “ADD <TYPE> <NUM>” command.
        -:  167:// Fills `response` with either “OK: Carbon=.. Oxygen=.. Hydrogen=..\n”
        -:  168:// or an ERROR line.
        -:  169:// ----------------------------------------------------------------------------
       12:  170:void parse_and_update_tcp(const char *line, char *response, size_t resp_size) {
        -:  171:
       12:  172:    if (save_file_path) {
       12:  173:        load_atoms_from_file(save_file_path, 0, 0, 0);
        -:  174:    }
        -:  175:    
        -:  176:    
        -:  177:    char temp[MAXBUF];
       12:  178:    strncpy(temp, line, sizeof(temp));
       12:  179:    temp[sizeof(temp)-1] = '\0';
        -:  180:
       12:  181:    char *saveptr = NULL;
       12:  182:    char *token_cmd  = strtok_r(temp, " \t\r\n", &saveptr);  // “ADD”
       12:  183:    char *token_type = strtok_r(NULL,   " \t\r\n", &saveptr);  // “CARBON”|“OXYGEN”|“HYDROGEN”
       12:  184:    char *token_num  = strtok_r(NULL,   " \t\r\n", &saveptr);  // e.g. “100”
        -:  185:
       12:  186:    if (!token_cmd || !token_type || !token_num) {
        1:  187:        snprintf(response, resp_size, "ERROR: invalid command\n");
        6:  188:        return;
        -:  189:    }
       11:  190:    if (strcmp(token_cmd, "ADD") != 0) {
        1:  191:        snprintf(response, resp_size, "ERROR: invalid command\n");
        1:  192:        return;
        -:  193:    }
        -:  194:
       10:  195:    enum { CARBON, OXYGEN, HYDROGEN, TYPE_UNKNOWN } type = TYPE_UNKNOWN;
       10:  196:    if (strcmp(token_type, "CARBON") == 0)      type = CARBON;
        5:  197:    else if (strcmp(token_type, "OXYGEN") == 0) type = OXYGEN;
        3:  198:    else if (strcmp(token_type, "HYDROGEN") == 0) type = HYDROGEN;
        -:  199:    else {
        2:  200:        snprintf(response, resp_size, "ERROR: invalid atom type\n");
        2:  201:        return;
        -:  202:    }
        -:  203:
        8:  204:    char *endptr = NULL;
        8:  205:    unsigned long long val = strtoull(token_num, &endptr, 10);
        8:  206:    if (endptr == token_num || *endptr != '\0') {
        1:  207:        snprintf(response, resp_size, "ERROR: invalid number\n");
        1:  208:        return;
        -:  209:    }
        7:  210:    if (val > MAX_ATOMS) {
        1:  211:        snprintf(response, resp_size, "ERROR: number too large\n");
        1:  212:        return;
        -:  213:    }
        -:  214:
        -:  215:    // Attempt to add to the correct stock, checking for overflow.
        6:  216:    switch (type) {
        4:  217:        case CARBON:
        4:  218:            if (atom_stock.carbon + val > MAX_ATOMS) {
    #####:  219:                snprintf(response, resp_size, "ERROR: capacity exceeded\n");
    #####:  220:                return;
        -:  221:            }
        4:  222:            atom_stock.carbon += val;
        4:  223:            break;
        1:  224:        case OXYGEN:
        1:  225:            if (atom_stock.oxygen + val > MAX_ATOMS) {
    #####:  226:                snprintf(response, resp_size, "ERROR: capacity exceeded\n");
    #####:  227:                return;
        -:  228:            }
        1:  229:            atom_stock.oxygen += val;
        1:  230:            break;
        1:  231:        case HYDROGEN:
        1:  232:            if (atom_stock.hydrogen + val > MAX_ATOMS) {
    #####:  233:                snprintf(response, resp_size, "ERROR: capacity exceeded\n");
    #####:  234:                return;
        -:  235:            }
        1:  236:            atom_stock.hydrogen += val;
        1:  237:            break;
    #####:  238:        default:
    #####:  239:            snprintf(response, resp_size, "ERROR: unknown error\n");
    #####:  240:            return;
        -:  241:    }
        -:  242:
        -:  243:    // Print updated atom inventory to server console
        6:  244:    printf("SERVER INVENTORY (atoms): Carbon=%llu  Oxygen=%llu  Hydrogen=%llu\n",
        6:  245:           (unsigned long long)atom_stock.carbon,
        6:  246:           (unsigned long long)atom_stock.oxygen,
        6:  247:           (unsigned long long)atom_stock.hydrogen);
        -:  248:
        -:  249:    //if there is a save flag , we will save the atoms to the file.
        6:  250:    if (save_file_path) {
        6:  251:        save_atoms_to_file(save_file_path);
        -:  252:    }
        -:  253:
        -:  254:    // Build success response
        6:  255:    snprintf(response, resp_size,
        -:  256:             "OK: Carbon=%llu Oxygen=%llu Hydrogen=%llu\n",
        6:  257:             (unsigned long long)atom_stock.carbon,
        6:  258:             (unsigned long long)atom_stock.oxygen,
        6:  259:             (unsigned long long)atom_stock.hydrogen);
        -:  260:}
        -:  261:
        -:  262:// ----------------------------------------------------------------------------
        -:  263:// Parse and update a UDP “DELIVER <MOLECULE> <NUM>” command.
        -:  264:// Molecule → needs certain numbers of atoms; subtract if enough atoms; else error.
        -:  265:// Print the resulting inventory, then respond with a short “OK: Atoms left …\n”
        -:  266:// ----------------------------------------------------------------------------
       15:  267:void parse_and_update_udp(const char *line, char *response, size_t resp_size) {  
        -:  268:    
       15:  269:    if (save_file_path) {
       15:  270:        load_atoms_from_file(save_file_path, 0, 0, 0);
        -:  271:    }
        -:  272:    
        -:  273:    char temp[MAXBUF];
       15:  274:    strncpy(temp, line, sizeof(temp));
       15:  275:    temp[sizeof(temp)-1] = '\0';
        -:  276:
       15:  277:    char *saveptr = NULL;
       15:  278:    char *token_cmd = strtok_r(temp, " \t\r\n", &saveptr);  // “DELIVER”
       15:  279:    char *token_mol = strtok_r(NULL,   " \t\r\n", &saveptr);  // e.g. “WATER” or “CARBON”
        -:  280:
       15:  281:    if (!token_cmd || !token_mol) {
        1:  282:        snprintf(response, resp_size, "ERROR: invalid command\n");
       14:  283:        return;
        -:  284:    }
       14:  285:    if (strcmp(token_cmd, "DELIVER") != 0) {
        1:  286:        snprintf(response, resp_size, "ERROR: invalid command\n");
        1:  287:        return;
        -:  288:    }
        -:  289:
        -:  290:    // Build full molecule name if needed (“CARBON DIOXIDE” → two tokens)
        -:  291:    char full_mol[MAXBUF];
       13:  292:    if (strcmp(token_mol, "CARBON") == 0) {
        2:  293:        char *token_next = strtok_r(NULL, " \t\r\n", &saveptr);
        2:  294:        if (!token_next || strcmp(token_next, "DIOXIDE") != 0) {
    #####:  295:            snprintf(response, resp_size, "ERROR: invalid molecule type\n");
    #####:  296:            return;
        -:  297:        }
        2:  298:        strcpy(full_mol, "CARBON DIOXIDE");
        -:  299:    }
       11:  300:    else if (strcmp(token_mol, "WATER") == 0) {
        6:  301:        strcpy(full_mol, "WATER");
        -:  302:    }
        5:  303:    else if (strcmp(token_mol, "GLUCOSE") == 0) {
        2:  304:        strcpy(full_mol, "GLUCOSE");
        -:  305:    }
        3:  306:    else if (strcmp(token_mol, "ALCOHOL") == 0) {
        1:  307:        strcpy(full_mol, "ALCOHOL");
        -:  308:    }
        -:  309:    else {
        2:  310:        snprintf(response, resp_size, "ERROR: invalid molecule type\n");
        2:  311:        return;
        -:  312:    }
        -:  313:
        -:  314:    // Next token must be a number
       11:  315:    char *token_num = strtok_r(NULL, " \t\r\n", &saveptr);
       11:  316:    if (!token_num) {
        1:  317:        snprintf(response, resp_size, "ERROR: missing number\n");
        1:  318:        return;
        -:  319:    }
        -:  320:    // Ensure no extra tokens
       10:  321:    char *token_extra = strtok_r(NULL, " \t\r\n", &saveptr);
       10:  322:    if (token_extra) {
        1:  323:        snprintf(response, resp_size, "ERROR: too many arguments\n");
        1:  324:        return;
        -:  325:    }
        -:  326:
        9:  327:    char *endptr = NULL;
        9:  328:    unsigned long long count = strtoull(token_num, &endptr, 10);
        9:  329:    if (endptr == token_num || *endptr != '\0') {
        1:  330:        snprintf(response, resp_size, "ERROR: invalid number\n");
        1:  331:        return;
        -:  332:    }
        8:  333:    if (count > MAX_ATOMS) {
    #####:  334:        snprintf(response, resp_size, "ERROR: number too large\n");
    #####:  335:        return;
        -:  336:    }
        -:  337:
        -:  338:    // Compute needed atoms for one molecule × count
        8:  339:    uint64_t req_carbon = 0, req_oxygen = 0, req_hydrogen = 0;
        8:  340:    if (strcmp(full_mol, "WATER") == 0) {
        -:  341:        // H2O: needs 2 H + 1 O per molecule
        3:  342:        req_hydrogen = 2ULL * count;
        3:  343:        req_oxygen   = 1ULL * count;
        3:  344:        req_carbon   = 0ULL;
        -:  345:    }
        5:  346:    else if (strcmp(full_mol, "CARBON DIOXIDE") == 0) {
        -:  347:        // CO2: needs 1 C + 2 O per molecule
        2:  348:        req_carbon   = 1ULL * count;
        2:  349:        req_oxygen   = 2ULL * count;
        2:  350:        req_hydrogen = 0ULL;
        -:  351:    }
        3:  352:    else if (strcmp(full_mol, "GLUCOSE") == 0) {
        -:  353:        // C6H12O6: needs 6 C + 12 H + 6 O per molecule
        2:  354:        req_carbon   = 6ULL * count;
        2:  355:        req_hydrogen = 12ULL * count;
        2:  356:        req_oxygen   = 6ULL * count;
        -:  357:    }
        1:  358:    else if (strcmp(full_mol, "ALCOHOL") == 0) {
        -:  359:        // C2H6O: needs 2 C + 6 H + 1 O per molecule
        1:  360:        req_carbon   = 2ULL * count;
        1:  361:        req_hydrogen = 6ULL * count;
        1:  362:        req_oxygen   = 1ULL * count;
        -:  363:    }
        -:  364:    else {
    #####:  365:        snprintf(response, resp_size, "ERROR: unknown molecule\n");
    #####:  366:        return;
        -:  367:    }
        -:  368:
        -:  369:    // Check if enough atoms exist
        8:  370:    if (atom_stock.carbon   < req_carbon) {
        2:  371:        snprintf(response, resp_size, "ERROR: not enough carbon atoms\n");
        2:  372:        return;
        -:  373:    }
        6:  374:    if (atom_stock.oxygen   < req_oxygen) {
        3:  375:        snprintf(response, resp_size, "ERROR: not enough oxygen atoms\n");
        3:  376:        return;
        -:  377:    }
        3:  378:    if (atom_stock.hydrogen < req_hydrogen) {
        2:  379:        snprintf(response, resp_size, "ERROR: not enough hydrogen atoms\n");
        2:  380:        return;
        -:  381:    }
        -:  382:
        -:  383:    // Subtract the required atoms
        1:  384:    atom_stock.carbon   -= req_carbon;
        1:  385:    atom_stock.oxygen   -= req_oxygen;
        1:  386:    atom_stock.hydrogen -= req_hydrogen;
        -:  387:
        -:  388:    // Print updated inventory 
        1:  389:    print_inventory();
        -:  390:
        -:  391:    //if there is a save flag , we will save the atoms to the file.
        1:  392:    if (save_file_path) {
        1:  393:        save_atoms_to_file(save_file_path);
        -:  394:    }
        -:  395:
        -:  396:    // Respond with a short “OK: Atoms left – Carbon=.. Oxygen=.. Hydrogen=..\n”
        1:  397:    snprintf(response, resp_size,
        -:  398:             "OK: Atoms left – Carbon=%llu Oxygen=%llu Hydrogen=%llu\n",
        1:  399:             (unsigned long long)atom_stock.carbon,
        1:  400:             (unsigned long long)atom_stock.oxygen,
        1:  401:             (unsigned long long)atom_stock.hydrogen);
        -:  402:}
        -:  403:
        -:  404:// ----------------------------------------------------------------------------
        -:  405:// handle_tcp_client():
        -:  406://   - read exactly one “ADD …” line (via recv), 
        -:  407://   - call parse_and_update_tcp(…), 
        -:  408://   - send the response back over that same TCP socket.
        -:  409:// Return false if client closed or a recv‐error occurred.
        -:  410:// ----------------------------------------------------------------------------
       22:  411:bool handle_tcp_client(int client_fd) {
        -:  412:    char buf[MAXBUF];
       22:  413:    ssize_t numbytes = recv(client_fd, buf, sizeof(buf)-1, 0);
       22:  414:    if (numbytes <= 0) {
        -:  415:        // 0 => client closed; <0 => recv error
       10:  416:        return false;
        -:  417:    }
       12:  418:    buf[numbytes] = '\0';
        -:  419:
        -:  420:    char response[MAXBUF];
       12:  421:    parse_and_update_tcp(buf, response, sizeof(response));
        -:  422:
       12:  423:    if (send(client_fd, response, strlen(response), 0) < 0) {
    #####:  424:        perror("send (TCP)");
        -:  425:    }
       12:  426:    return true;
        -:  427:}
        -:  428:// ----------------------------------------------------------------------------
        -:  429:// load_atoms_from_file():
        -:  430://      if the file exists and big enough , reads sizeof (atomStock) to the global var.
        -:  431://      else creating a new file , fills it with the values of the atoms and read the full struct to the file.
        -:  432:// ----------------------------------------------------------------------------
       48:  433:static void load_atoms_from_file(const char *path, uint64_t init_c, uint64_t init_o,uint64_t init_h)
        -:  434:{
        -:  435:    struct stat st;
        -:  436:    FILE *fp;
        -:  437:
        -:  438:    //if the file exists
       48:  439:    if (stat(path,&st) == 0){
       47:  440:        if(st.st_size >= (off_t)sizeof(atom_stock)){
        -:  441:            //reading all the struct from the file:
       39:  442:            fp = fopen(path,"rb");
       39:  443:            if (!fp){
    #####:  444:                perror("fopen (for read)");
    #####:  445:                exit(EXIT_FAILURE);
        -:  446:            }
       39:  447:            size_t n = fread(&atom_stock,1,sizeof(AtomStock),fp);
       39:  448:            if (n != sizeof(AtomStock)){
    #####:  449:                fprintf(stderr,"Error:could not read Atoms from file \n");
    #####:  450:                fclose(fp);
    #####:  451:                exit(EXIT_FAILURE);
        -:  452:            }
       39:  453:            fclose(fp);
       39:  454:            return;
        -:  455:        }
        -:  456:        //if file is too small , we will drop to create a new file.
        -:  457:    }
        -:  458:
        -:  459:    //if we reach here , file not exists or too small -> creating a new file :
        9:  460:    atom_stock.carbon = init_c;
        9:  461:    atom_stock.oxygen = init_o;
        9:  462:    atom_stock.hydrogen = init_h;
        -:  463:
        9:  464:    fp = fopen(path, "wb");
        9:  465:    if (!fp) {
    #####:  466:        perror("fopen for write");
    #####:  467:        exit(EXIT_FAILURE);
        -:  468:    }
        9:  469:    size_t w = fwrite(&atom_stock,1,sizeof(AtomStock),fp);
        9:  470:    if (w != sizeof(AtomStock)){
    #####:  471:        fprintf(stderr,"Error: could not write full Atoms struct to file \n");
    #####:  472:        fclose(fp);
    #####:  473:        exit(EXIT_FAILURE);
        -:  474:    }
        9:  475:    fclose(fp);
        -:  476:}
        -:  477:
        -:  478:
        -:  479:// ----------------------------------------------------------------------------
        -:  480:// save_atoms_to_file():
        -:  481://opens / creates the file in rb or wb. locks the file with flock to prevent parallel changes.
        -:  482://writes a block of our atoms struct with fwrite.
        -:  483://releases the lock and closes the files.
        -:  484:// ----------------------------------------------------------------------------
        9:  485:static void save_atoms_to_file(const char *path){
        9:  486:    FILE *fp = fopen(path,"r+b");
        9:  487:    if (!fp) { //if file does not exits we will try to create it
    #####:  488:        fp = fopen(path,"w+b");
    #####:  489:        if(!fp){
    #####:  490:            perror("fopen for save");
    #####:  491:            return;
        -:  492:        }
        -:  493:    }
        -:  494:
        9:  495:    int fd = fileno(fp); // should understand later
        9:  496:    if (fd < 0) {
    #####:  497:        perror("fileno");
    #####:  498:        fclose(fp);
    #####:  499:        return;
        -:  500:    }
        -:  501:
        -:  502:    //exlusive lock:
        9:  503:    if (flock(fd,LOCK_EX) < 0){
    #####:  504:        perror("flock LOCK_EX");
        -:  505:        //might be risky but we will keep going :D
        -:  506:    }
        -:  507:
        -:  508:    //writing:
        9:  509:    if (fseek(fp,0,SEEK_SET)!= 0)
    #####:  510:        perror("fseek");
        9:  511:    size_t w = fwrite(&atom_stock,1,sizeof(AtomStock),fp);
        9:  512:    if (w!=sizeof(AtomStock))
    #####:  513:        fprintf(stderr, "Error: could not write full Atom struct\n");
        9:  514:    fflush(fp);
        -:  515:
        -:  516:    //releasing the lock:
        9:  517:    if (flock(fd, LOCK_UN) < 0) {
    #####:  518:        perror("flock LOCK_UN");
        -:  519:    }
        9:  520:    fclose(fp);
        -:  521:
        -:  522:}   
        -:  523:
        -:  524:
        -:  525:
        -:  526:
        -:  527:
        -:  528:
        -:  529:// ----------------------------------------------------------------------------
        -:  530:// main():
        -:  531://   • parse flags (−c, −o, −h, −t, −T, −U, optionally −s or −d)
        -:  532://   • set up atom_stock
        -:  533://   • possibly install SIGALRM
        -:  534://   • create and bind TCP listen socket on port T
        -:  535://   • create and bind UDP socket on port U
        -:  536://   • optionally create & bind UDS‐STREAM if −s was given
        -:  537://   • optionally create & bind UDS‐DGRAM if −d was given
        -:  538://   • enter select() loop: monitor 
        -:  539://       – tcp_listen_fd, 
        -:  540://       – udp_fd, 
        -:  541://       – any accepted TCP client fds, 
        -:  542://       – STDIN_FILENO, 
        -:  543://       – uds_stream_fd (if set), 
        -:  544://       – uds_dgram_fd (if set).
        -:  545://   • on tcp_listen_fd ready: accept new connection, add to client list
        -:  546://   • on udp_fd ready: recvfrom, parse_and_update_udp, sendto reply
        -:  547://   • on any TCP client fd ready: call handle_tcp_client()
        -:  548://   • on STDIN_FILENO ready: handle “GEN …” console commands
        -:  549://   • on uds_stream_fd ready: accept a UDS‐STREAM connection, call handle_tcp_client() over it, close it
        -:  550://   • on uds_dgram_fd ready: recvfrom a “DELIVER …” datagram from a UDS client, parse_and_update_udp, sendto reply back to that UDS client
        -:  551://   • if timeout triggered, break out and clean up
        -:  552:// ----------------------------------------------------------------------------
       26:  553:int main(int argc, char *argv[]) {
        -:  554:    // 1) Parse command‐line options
       26:  555:    uint64_t init_carbon   = 0;
       26:  556:    uint64_t init_oxygen   = 0;
       26:  557:    uint64_t init_hydrogen = 0;
       26:  558:    int timeout_secs       = 0;
       26:  559:    int tcp_port           = -1;
       26:  560:    int udp_port           = -1;
       26:  561:    char *uds_stream_path  = NULL;
       26:  562:    char *uds_dgram_path   = NULL;
        -:  563:
       26:  564:    struct option long_opts[] = {
        -:  565:        {"carbon",       required_argument, 0, 'c'},
        -:  566:        {"oxygen",       required_argument, 0, 'o'},
        -:  567:        {"hydrogen",     required_argument, 0, 'h'},
        -:  568:        {"timeout",      required_argument, 0, 't'},
        -:  569:        {"tcp-port",     required_argument, 0, 'T'},
        -:  570:        {"udp-port",     required_argument, 0, 'U'},
        -:  571:        {"stream-path",  required_argument, 0, 's'},
        -:  572:        {"datagram-path",required_argument, 0, 'd'},
        -:  573:        {"save-file",required_argument, 0, 'f'},
        -:  574:        {0,0,0,0}
        -:  575:    };
       26:  576:    const char *short_opts = "c:o:h:t:T:U:s:d:f:";
        -:  577:    int opt;
      160:  578:    while ((opt = getopt_long(argc, argv, short_opts, long_opts, NULL)) != -1) {
      136:  579:        switch (opt) {
       24:  580:            case 'c':
       24:  581:                init_carbon = strtoull(optarg, NULL, 10);
       24:  582:                break;
       24:  583:            case 'o':
       24:  584:                init_oxygen = strtoull(optarg, NULL, 10);
       24:  585:                break;
       24:  586:            case 'h':
       24:  587:                init_hydrogen = strtoull(optarg, NULL, 10);
       24:  588:                break;
        1:  589:            case 't':
        1:  590:                timeout_secs = atoi(optarg);
        1:  591:                break;
       24:  592:            case 'T':
       24:  593:                tcp_port = atoi(optarg);
       24:  594:                break;
       24:  595:            case 'U':
       24:  596:                udp_port = atoi(optarg);
       24:  597:                break;
        2:  598:            case 's':
        2:  599:                uds_stream_path = optarg;
        2:  600:                break;
        2:  601:            case 'd':
        2:  602:                uds_dgram_path = optarg;
        2:  603:                break;
        9:  604:            case 'f':
        9:  605:                save_file_path = optarg;
        9:  606:                break;
        2:  607:            default:
        2:  608:                fprintf(stderr,
        -:  609:                    "Usage: %s -c <carbon> -o <oxygen> -h <hydrogen> "
        -:  610:                    "[-t <timeout>] -T <tcp_port> -U <udp_port> \\\n"
        -:  611:                    "       [-s <uds_stream_path>] [-d <uds_dgram_path>] -f <file path>\n"
        -:  612:                    " -f <file path>",
        -:  613:                    argv[0]);
        2:  614:                exit(EXIT_FAILURE);
        -:  615:        }
        -:  616:    }
        -:  617:
        -:  618:    // Enforce: −c, −o, −h, −T, −U are all mandatory.
       24:  619:    if (tcp_port <= 0 || udp_port <= 0)
        -:  620:    {
        3:  621:        fprintf(stderr,
        -:  622:            "ERROR: you must specify "
        -:  623:            "-T <tcp_port> -U <udp_port>.\n"
        -:  624:            "Usage: %s -c <carbon> -o <oxygen> -h <hydrogen> "
        -:  625:            "[-t <timeout>] -T <tcp_port> -U <udp_port> \\\n"
        -:  626:            "       [-s <uds_stream_path>] [-d <uds_dgram_path>]  -f <file path>\n",
        -:  627:            argv[0]);
        3:  628:        exit(EXIT_FAILURE);
        -:  629:    }
        -:  630:
        -:  631:    // if we did use the f flag
       21:  632:    if (save_file_path) {
        9:  633:        load_atoms_from_file(save_file_path, init_carbon, init_oxygen, init_hydrogen);
        -:  634:    }
        -:  635:    else {
        -:  636:        // אם אין -f, מאתחלים inv לערכי ברירת המחדל
       12:  637:        atom_stock.carbon         = init_carbon;
       12:  638:        atom_stock.oxygen         = init_oxygen;
       12:  639:        atom_stock.hydrogen       = init_hydrogen;
        -:  640:    }
        -:  641:
        -:  642:    // 3) If timeout_secs > 0, install SIGALRM handler and call alarm(timeout_secs)
       21:  643:    if (timeout_secs > 0) {
        -:  644:        struct sigaction sa_alrm;
        1:  645:        memset(&sa_alrm, 0, sizeof(sa_alrm));
        1:  646:        sa_alrm.sa_handler = alarm_handler;
        1:  647:        sigemptyset(&sa_alrm.sa_mask);
        1:  648:        sa_alrm.sa_flags = 0;  // not using SA_RESTART
        1:  649:        if (sigaction(SIGALRM, &sa_alrm, NULL) == -1) {
    #####:  650:            perror("sigaction(SIGALRM)");
    #####:  651:            exit(EXIT_FAILURE);
        -:  652:        }
        1:  653:        alarm(timeout_secs);
        -:  654:    }
        -:  655:
        -:  656:    // Convert ports to strings for getaddrinfo
        -:  657:    char tcp_port_str[6], udp_port_str[6];
       21:  658:    snprintf(tcp_port_str, sizeof(tcp_port_str), "%d", tcp_port);
       21:  659:    snprintf(udp_port_str, sizeof(udp_port_str), "%d", udp_port);
        -:  660:
        -:  661:    // ----------------------------------------------------------------------------
        -:  662:    // 4) Create TCP listening socket on tcp_port
        -:  663:    // ----------------------------------------------------------------------------
        -:  664:    int tcp_listen_fd;
        -:  665:    {
        -:  666:        struct addrinfo hints_tcp;
        -:  667:        struct addrinfo *servinfo_tcp, *p_tcp;
       21:  668:        memset(&hints_tcp, 0, sizeof(hints_tcp));
       21:  669:        hints_tcp.ai_family   = AF_INET;      // IPv4 only (for simplicity)
       21:  670:        hints_tcp.ai_socktype = SOCK_STREAM;  // TCP
       21:  671:        hints_tcp.ai_flags    = AI_PASSIVE;   // use local IP
        -:  672:
        -:  673:        int rv;
       21:  674:        if ((rv = getaddrinfo(NULL, tcp_port_str, &hints_tcp, &servinfo_tcp)) != 0) {
    #####:  675:            fprintf(stderr, "getaddrinfo (TCP): %s\n", gai_strerror(rv));
    #####:  676:            exit(EXIT_FAILURE);
        -:  677:        }
        -:  678:
       21:  679:        int yes = 1;
      21*:  680:        for (p_tcp = servinfo_tcp; p_tcp != NULL; p_tcp = p_tcp->ai_next) {
       21:  681:            tcp_listen_fd = socket(p_tcp->ai_family, p_tcp->ai_socktype, p_tcp->ai_protocol);
      21*:  682:            if (tcp_listen_fd < 0) {
    #####:  683:                perror("socket (TCP)");
    #####:  684:                continue;
        -:  685:            }
       21:  686:            if (setsockopt(tcp_listen_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1) {
    #####:  687:                perror("setsockopt (TCP)");
    #####:  688:                close(tcp_listen_fd);
    #####:  689:                exit(EXIT_FAILURE);
        -:  690:            }
      21*:  691:            if (bind(tcp_listen_fd, p_tcp->ai_addr, p_tcp->ai_addrlen) < 0) {
    #####:  692:                perror("bind (TCP)");
    #####:  693:                close(tcp_listen_fd);
    #####:  694:                continue;
        -:  695:            }
        -:  696:            // Bound successfully
       21:  697:            break;
        -:  698:        }
       21:  699:        if (p_tcp == NULL) {
    #####:  700:            fprintf(stderr, "Error: failed to bind TCP on port %s\n", tcp_port_str);
    #####:  701:            exit(EXIT_FAILURE);
        -:  702:        }
       21:  703:        freeaddrinfo(servinfo_tcp);
        -:  704:
       21:  705:        if (listen(tcp_listen_fd, BACKLOG) < 0) {
    #####:  706:            perror("listen (TCP)");
    #####:  707:            exit(EXIT_FAILURE);
        -:  708:        }
       21:  709:        printf("server (TCP): listening on port %s...\n", tcp_port_str);
        -:  710:
        -:  711:        // Install SIGCHLD handler for TCP child reaping (if we ever fork)
        -:  712:        struct sigaction sa_chld;
       21:  713:        sa_chld.sa_handler = sigchld_handler;
       21:  714:        sigemptyset(&sa_chld.sa_mask);
       21:  715:        sa_chld.sa_flags = SA_RESTART;
       21:  716:        if (sigaction(SIGCHLD, &sa_chld, NULL) == -1) {
    #####:  717:            perror("sigaction(SIGCHLD)");
    #####:  718:            exit(EXIT_FAILURE);
        -:  719:        }
        -:  720:    }
        -:  721:
        -:  722:    // ----------------------------------------------------------------------------
        -:  723:    // 5) Create UDP socket on udp_port
        -:  724:    // ----------------------------------------------------------------------------
        -:  725:    int udp_fd;
        -:  726:    {
        -:  727:        struct addrinfo hints_udp;
        -:  728:        struct addrinfo *servinfo_udp, *p_udp;
       21:  729:        memset(&hints_udp, 0, sizeof(hints_udp));
       21:  730:        hints_udp.ai_family   = AF_INET;      // IPv4 only
       21:  731:        hints_udp.ai_socktype = SOCK_DGRAM;   // UDP
       21:  732:        hints_udp.ai_flags    = AI_PASSIVE;   // use local IP
        -:  733:
        -:  734:        int rv2;
       21:  735:        if ((rv2 = getaddrinfo(NULL, udp_port_str, &hints_udp, &servinfo_udp)) != 0) {
    #####:  736:            fprintf(stderr, "getaddrinfo (UDP): %s\n", gai_strerror(rv2));
    #####:  737:            exit(EXIT_FAILURE);
        -:  738:        }
      21*:  739:        for (p_udp = servinfo_udp; p_udp != NULL; p_udp = p_udp->ai_next) {
       21:  740:            udp_fd = socket(p_udp->ai_family, p_udp->ai_socktype, p_udp->ai_protocol);
      21*:  741:            if (udp_fd < 0) {
    #####:  742:                perror("socket (UDP)");
    #####:  743:                continue;
        -:  744:            }
      21*:  745:            if (bind(udp_fd, p_udp->ai_addr, p_udp->ai_addrlen) < 0) {
    #####:  746:                perror("bind (UDP)");
    #####:  747:                close(udp_fd);
    #####:  748:                continue;
        -:  749:            }
        -:  750:            // Bound successfully
       21:  751:            break;
        -:  752:        }
       21:  753:        if (p_udp == NULL) {
    #####:  754:            fprintf(stderr, "Error: failed to bind UDP on port %s\n", udp_port_str);
    #####:  755:            exit(EXIT_FAILURE);
        -:  756:        }
       21:  757:        freeaddrinfo(servinfo_udp);
        -:  758:
       21:  759:        printf("server (UDP): listening on port %s...\n", udp_port_str);
        -:  760:    }
        -:  761:
        -:  762:    // ----------------------------------------------------------------------------
        -:  763:    // 6) create UDS‐STREAM socket "-s"
        -:  764:    // ----------------------------------------------------------------------------
       21:  765:    int uds_stream_fd = -1;
       21:  766:    if (uds_stream_path) {
        -:  767:        // Remove any existing file at that path, to avoid “address already in use”
        2:  768:        unlink(uds_stream_path);
        -:  769:
        2:  770:        uds_stream_fd = socket(AF_UNIX, SOCK_STREAM, 0);
        2:  771:        if (uds_stream_fd < 0) {
    #####:  772:            perror("socket (UDS_STREAM)");
    #####:  773:            exit(EXIT_FAILURE);
        -:  774:        }
        -:  775:        struct sockaddr_un uds_stream_addr;
        2:  776:        memset(&uds_stream_addr, 0, sizeof(uds_stream_addr));
        2:  777:        uds_stream_addr.sun_family = AF_UNIX;
        2:  778:        strncpy(uds_stream_addr.sun_path, uds_stream_path,
        -:  779:                sizeof(uds_stream_addr.sun_path) - 1);
        -:  780:
        2:  781:        if (bind(uds_stream_fd, (struct sockaddr*)&uds_stream_addr,
        -:  782:                 sizeof(uds_stream_addr)) < 0)
        -:  783:        {
    #####:  784:            perror("bind (UDS_STREAM)");
    #####:  785:            close(uds_stream_fd);
    #####:  786:            exit(EXIT_FAILURE);
        -:  787:        }
        2:  788:        if (listen(uds_stream_fd, BACKLOG) < 0) {
    #####:  789:            perror("listen (UDS_STREAM)");
    #####:  790:            close(uds_stream_fd);
    #####:  791:            exit(EXIT_FAILURE);
        -:  792:        }
        2:  793:        printf("server (UDS_STREAM): listening on path %s\n", uds_stream_path);
        -:  794:    }
        -:  795:
        -:  796:    // ----------------------------------------------------------------------------
        -:  797:    // 7) create UDS‐DGRAM socket "-d"
        -:  798:    // ----------------------------------------------------------------------------
       21:  799:    int uds_dgram_fd = -1;
       21:  800:    if (uds_dgram_path) {
        2:  801:        unlink(uds_dgram_path);
        -:  802:
        2:  803:        uds_dgram_fd = socket(AF_UNIX, SOCK_DGRAM, 0);
        2:  804:        if (uds_dgram_fd < 0) {
    #####:  805:            perror("socket (UDS_DGRAM)");
    #####:  806:            exit(EXIT_FAILURE);
        -:  807:        }
        -:  808:        struct sockaddr_un uds_dgram_addr;
        2:  809:        memset(&uds_dgram_addr, 0, sizeof(uds_dgram_addr));
        2:  810:        uds_dgram_addr.sun_family = AF_UNIX;
        2:  811:        strncpy(uds_dgram_addr.sun_path, uds_dgram_path,
        -:  812:                sizeof(uds_dgram_addr.sun_path) - 1);
        -:  813:
        2:  814:        if (bind(uds_dgram_fd, (struct sockaddr*)&uds_dgram_addr,
        -:  815:                 sizeof(uds_dgram_addr)) < 0)
        -:  816:        {
    #####:  817:            perror("bind (UDS_DGRAM)");
    #####:  818:            close(uds_dgram_fd);
    #####:  819:            exit(EXIT_FAILURE);
        -:  820:        }
        2:  821:        printf("server (UDS_DGRAM): bound on path %s\n", uds_dgram_path);
        -:  822:    }
        -:  823:
        -:  824:    // ----------------------------------------------------------------------------
        -:  825:    // 8) Initialize an array of active TCP client fds
        -:  826:    // ----------------------------------------------------------------------------
        -:  827:    int client_fds[MAX_CLIENTS];
    21525:  828:    for (int i = 0; i < MAX_CLIENTS; i++) {
    21504:  829:        client_fds[i] = -1;  // –1 means “empty slot”
        -:  830:    }
        -:  831:
        -:  832:    // ----------------------------------------------------------------------------
        -:  833:    // 9) Print the console prompt and initial inventory
        -:  834:    // ----------------------------------------------------------------------------
       21:  835:    printf("\n=== DRINKS_BAR SERVER READY ===\n");
       21:  836:    printf("Valid console commands (type here):\n");
       21:  837:    printf("  GEN SOFT DRINK\n");
       21:  838:    printf("  GEN VODKA\n");
       21:  839:    printf("  GEN CHAMPAGNE\n\n");
       21:  840:    printf("Press Ctrl+C to terminate.\n\n");
       21:  841:    print_inventory();
        -:  842:
        -:  843:    // ----------------------------------------------------------------------------
        -:  844:    // 10) Enter the main select() loop
        -:  845:    // ----------------------------------------------------------------------------
       54:  846:    while (1) {
       75:  847:        if (timed_out) {
        -:  848:            // Timeout triggered ⇒ no activity within the last <timeout_secs> seconds
        1:  849:            printf("TIMEOUT: no activity for %d seconds. Shutting down.\n", timeout_secs);
        1:  850:            break;
        -:  851:        }
        -:  852:
        -:  853:        fd_set read_fds;
     1258:  854:        FD_ZERO(&read_fds);
       74:  855:        int max_fd = -1;
        -:  856:
        -:  857:        // a) Always watch tcp_listen_fd
       74:  858:        FD_SET(tcp_listen_fd, &read_fds);
       74:  859:        if (tcp_listen_fd > max_fd) max_fd = tcp_listen_fd;
        -:  860:
        -:  861:        // b) Always watch udp_fd
       74:  862:        FD_SET(udp_fd, &read_fds);
       74:  863:        if (udp_fd > max_fd) max_fd = udp_fd;
        -:  864:
        -:  865:        // c) Watch all active TCP client fds
    75850:  866:        for (int i = 0; i < MAX_CLIENTS; i++) {
    75776:  867:            if (client_fds[i] != -1) {
       20:  868:                FD_SET(client_fds[i], &read_fds);
       20:  869:                if (client_fds[i] > max_fd) {
       20:  870:                    max_fd = client_fds[i];
        -:  871:                }
        -:  872:            }
        -:  873:        }
        -:  874:
        -:  875:        // d) Watch keyboard (STDIN_FILENO)
       74:  876:        FD_SET(STDIN_FILENO, &read_fds);
      74*:  877:        if (STDIN_FILENO > max_fd) max_fd = STDIN_FILENO;
        -:  878:
        -:  879:        // e) If UDS_STREAM was created, watch uds_stream_fd
       74:  880:        if (uds_stream_path) {
        6:  881:            FD_SET(uds_stream_fd, &read_fds);
        6:  882:            if (uds_stream_fd > max_fd) max_fd = uds_stream_fd;
        -:  883:        }
        -:  884:
        -:  885:        // f) If UDS_DGRAM was created, watch uds_dgram_fd
       74:  886:        if (uds_dgram_path) {
        6:  887:            FD_SET(uds_dgram_fd, &read_fds);
        6:  888:            if (uds_dgram_fd > max_fd) max_fd = uds_dgram_fd;
        -:  889:        }
        -:  890:
        -:  891:        // Wait until at least one descriptor is ready
       74:  892:        int ready = select(max_fd + 1, &read_fds, NULL, NULL, NULL);
       74:  893:        if (ready < 0) {
        1:  894:            if (errno == EINTR) {
        -:  895:                // Interrupted by a signal (likely SIGALRM). Recompute if timed_out.
        1:  896:                continue;
        -:  897:            }
    #####:  898:            perror("select");
    #####:  899:            exit(EXIT_FAILURE);
        -:  900:        }
        -:  901:
        -:  902:        // -------------------------------------------------------
        -:  903:        // 10.1 New incoming TCP connection?
        -:  904:        // If tcp_listen_fd is ready, accept() it and store in client_fds[].
        -:  905:        // -------------------------------------------------------
       73:  906:        if (FD_ISSET(tcp_listen_fd, &read_fds)) {
        -:  907:            struct sockaddr_storage client_addr;
       10:  908:            socklen_t addr_len = sizeof(client_addr);
       10:  909:            int new_fd = accept(tcp_listen_fd,
        -:  910:                                (struct sockaddr*)&client_addr,
        -:  911:                                &addr_len);
       10:  912:            if (new_fd < 0) {
    #####:  913:                perror("accept (TCP)");
        -:  914:            } else {
        -:  915:                // store new_fd in the first empty slot
       10:  916:                bool added = false;
      10*:  917:                for (int i = 0; i < MAX_CLIENTS; i++) {
       10:  918:                    if (client_fds[i] == -1) {
       10:  919:                        client_fds[i] = new_fd;
       10:  920:                        added = true;
       10:  921:                        break;
        -:  922:                    }
        -:  923:                }
       10:  924:                if (!added) {
        -:  925:                    // too many clients; drop this connection
    #####:  926:                    close(new_fd);
        -:  927:                } else {
        -:  928:                    // print the new client's IPv4 address
        -:  929:                    char ipstr[INET_ADDRSTRLEN];
       10:  930:                    struct sockaddr_in *sa = (struct sockaddr_in *)&client_addr;
       10:  931:                    inet_ntop(AF_INET, &sa->sin_addr, ipstr, sizeof(ipstr));
       10:  932:                    printf("New TCP client from %s\n", ipstr);
        -:  933:                }
        -:  934:            }
        -:  935:            // Reset alarm if using timeout
       10:  936:            if (timeout_secs > 0) {
    #####:  937:                alarm(timeout_secs);
    #####:  938:                timed_out = 0;
        -:  939:            }
        -:  940:        }
        -:  941:
        -:  942:        // -------------------------------------------------------
        -:  943:        // 10.2 Incoming UDP datagram?
        -:  944:        // If udp_fd is ready, recvfrom() it, parse_and_update_udp(), sendto() the reply.
        -:  945:        // -------------------------------------------------------
       73:  946:        if (FD_ISSET(udp_fd, &read_fds)) {
        -:  947:            char buf[MAXBUF];
        -:  948:            struct sockaddr_storage client_addr;
       13:  949:            socklen_t addr_len = sizeof(client_addr);
       13:  950:            ssize_t numbytes = recvfrom(
        -:  951:                udp_fd,
        -:  952:                buf, sizeof(buf)-1,
        -:  953:                0,
        -:  954:                (struct sockaddr*)&client_addr,
        -:  955:                &addr_len
        -:  956:            );
       13:  957:            if (numbytes < 0) {
    #####:  958:                perror("recvfrom (UDP)");
        -:  959:            } else {
       13:  960:                buf[numbytes] = '\0';
        -:  961:                char response[MAXBUF];
       13:  962:                parse_and_update_udp(buf, response, sizeof(response));
        -:  963:                // reply to exactly that client address:
       13:  964:                if (sendto(
        -:  965:                        udp_fd,
        -:  966:                        response, strlen(response),
        -:  967:                        0,
        -:  968:                        (struct sockaddr*)&client_addr,
        -:  969:                        addr_len
        -:  970:                    ) < 0)
        -:  971:                {
    #####:  972:                    perror("sendto (UDP)");
        -:  973:                }
        -:  974:            }
       13:  975:            if (timeout_secs > 0) {
    #####:  976:                alarm(timeout_secs);
    #####:  977:                timed_out = 0;
        -:  978:            }
        -:  979:        }
        -:  980:
        -:  981:        // -------------------------------------------------------
        -:  982:        // 10.3 Check each active TCP client descriptor: 
        -:  983:        // if ready, call handle_tcp_client(); if it returns false, close & remove.
        -:  984:        // -------------------------------------------------------
    74825:  985:        for (int i = 0; i < MAX_CLIENTS; i++) {
    74752:  986:            int fd = client_fds[i];
    74752:  987:            if (fd != -1 && FD_ISSET(fd, &read_fds)) {
       20:  988:                if (!handle_tcp_client(fd)) {
       10:  989:                    close(fd);
       10:  990:                    client_fds[i] = -1;
        -:  991:                }
        -:  992:                // Reset alarm if using timeout
       20:  993:                if (timeout_secs > 0) {
    #####:  994:                    alarm(timeout_secs);
    #####:  995:                    timed_out = 0;
        -:  996:                }
        -:  997:            }
        -:  998:        }
        -:  999:
        -: 1000:        // -------------------------------------------------------
        -: 1001:        // 10.4 Console keyboard input (STDIN_FILENO)?
        -: 1002:        // If ready, read one line, interpret “GEN …” commands.
        -: 1003:        // -------------------------------------------------------
       73: 1004:        if (FD_ISSET(STDIN_FILENO, &read_fds)) {
       26: 1005:            if (save_file_path) {
        8: 1006:                load_atoms_from_file(save_file_path, 0, 0, 0);
        -: 1007:            }
        -: 1008:            char linebuf[MAXBUF];
       26: 1009:            if (fgets(linebuf, sizeof(linebuf), stdin) != NULL) {
        -: 1010:                // strip trailing newline
        6: 1011:                size_t L = strlen(linebuf);
        6: 1012:                if (L > 0 && linebuf[L-1] == '\n') {
        6: 1013:                    linebuf[L-1] = '\0';
        -: 1014:                }
        -: 1015:                // Expect “GEN <BEVERAGE>”
        6: 1016:                char *cmd = strtok(linebuf, " \t");
        6: 1017:                if (!cmd || strcmp(cmd, "GEN") != 0) {
    #####: 1018:                    printf("ERROR: invalid console command\n");
        -: 1019:                } else {
        6: 1020:                    char *drink = strtok(NULL, " \t");
        6: 1021:                    if (!drink) {
        1: 1022:                        printf("ERROR: missing drink type after GEN\n");
        -: 1023:                    }
        5: 1024:                    else if (strcmp(drink, "SOFT") == 0) {
        2: 1025:                        char *maybe_drink = strtok(NULL, " \t");
        2: 1026:                        if (!maybe_drink || strcmp(maybe_drink, "DRINK") != 0) {
        1: 1027:                            printf("ERROR: did you mean 'GEN SOFT DRINK'?\n");
        -: 1028:                        } else {
        -: 1029:                            // Soft drink requires 6 C, 14 H, 9 O
        1: 1030:                            uint64_t c = atom_stock.carbon / 6;
        1: 1031:                            uint64_t h = atom_stock.hydrogen / 14;
        1: 1032:                            uint64_t o = atom_stock.oxygen / 9;
        1: 1033:                            uint64_t can_make = c;
       1*: 1034:                            if (h < can_make) can_make = h;
        1: 1035:                            if (o < can_make) can_make = o;
        1: 1036:                            printf("You can make up to %llu SOFT DRINK(s)\n",
        -: 1037:                                   (unsigned long long)can_make);
        -: 1038:                        }
        -: 1039:                    }
        3: 1040:                    else if (strcmp(drink, "VODKA") == 0) {
        -: 1041:                        // Vodka requires 8 C, 20 H, 8 O
        1: 1042:                        uint64_t c = atom_stock.carbon / 8;
        1: 1043:                        uint64_t h = atom_stock.hydrogen / 20;
        1: 1044:                        uint64_t o = atom_stock.oxygen / 8;
        1: 1045:                        uint64_t can_make = c;
       1*: 1046:                        if (h < can_make) can_make = h;
       1*: 1047:                        if (o < can_make) can_make = o;
        1: 1048:                        printf("You can make up to %llu VODKA(s)\n",
        -: 1049:                               (unsigned long long)can_make);
        -: 1050:                    }
        2: 1051:                    else if (strcmp(drink, "CHAMPAGNE") == 0) {
        -: 1052:                        // Champagne requires 3 C, 9 H, 4 O
        1: 1053:                        uint64_t c = atom_stock.carbon / 3;
        1: 1054:                        uint64_t h = atom_stock.hydrogen / 9;
        1: 1055:                        uint64_t o = atom_stock.oxygen / 4;
        1: 1056:                        uint64_t can_make = c;
       1*: 1057:                        if (h < can_make) can_make = h;
        1: 1058:                        if (o < can_make) can_make = o;
        1: 1059:                        printf("You can make up to %llu CHAMPAGNE(s)\n",
        -: 1060:                               (unsigned long long)can_make);
        -: 1061:                    }
        -: 1062:                    else {
        1: 1063:                        printf("ERROR: unknown drink type '%s'\n", drink);
        -: 1064:                    }
        -: 1065:                }
        -: 1066:            } else {
        -: 1067:                // EOF (Ctrl+D) or error reading stdin ⇒ exit loop
       20: 1068:                printf("Console closed or error – exiting.\n");
       20: 1069:                break;
        -: 1070:            }
        6: 1071:            if (timeout_secs > 0) {
    #####: 1072:                alarm(timeout_secs);
    #####: 1073:                timed_out = 0;
        -: 1074:            }
        -: 1075:        }
        -: 1076:
        -: 1077:        // -------------------------------------------------------
        -: 1078:        // 10.5 Accept a new UDS_STREAM connection (if that socket exists)
        -: 1079:        // Once accepted, handle exactly one “ADD …” on that connection and close.
        -: 1080:        // -------------------------------------------------------
       53: 1081:        if (uds_stream_path && uds_stream_fd >= 0 && FD_ISSET(uds_stream_fd, &read_fds)) {
        2: 1082:            int new_un_fd = accept(uds_stream_fd, NULL, NULL);
        2: 1083:            if (new_un_fd < 0) {
    #####: 1084:                perror("accept (UDS_STREAM)");
        -: 1085:            } else {
        2: 1086:                if (save_file_path) {
        2: 1087:                    load_atoms_from_file(save_file_path, 0,0,0);
        -: 1088:                }
        -: 1089:                // Use the same TCP‐handler for “ADD …” lines
        2: 1090:                if (!handle_tcp_client(new_un_fd)) {
        -: 1091:                    // either closed immediately or error
        -: 1092:                }
        2: 1093:                close(new_un_fd);
        -: 1094:            }
        2: 1095:            if (timeout_secs > 0) {
    #####: 1096:                alarm(timeout_secs);
    #####: 1097:                timed_out = 0;
        -: 1098:            }
        -: 1099:        }
        -: 1100:
        -: 1101:        // -------------------------------------------------------
        -: 1102:        // 10.6 Receive one UDS_DGRAM datagram “DELIVER …” (if that socket exists)
        -: 1103:        // Parse & respond to that client’s address over UDS datagram.
        -: 1104:        // -------------------------------------------------------
       53: 1105:        if (uds_dgram_path && uds_dgram_fd >= 0 && FD_ISSET(uds_dgram_fd, &read_fds)) {
        -: 1106:            char buf[MAXBUF];
        -: 1107:            struct sockaddr_un cli_un;
        2: 1108:            socklen_t cli_len = sizeof(cli_un);
        2: 1109:            ssize_t nbytes = recvfrom(
        -: 1110:                uds_dgram_fd,
        -: 1111:                buf, sizeof(buf)-1,
        -: 1112:                0,
        -: 1113:                (struct sockaddr*)&cli_un,
        -: 1114:                &cli_len
        -: 1115:            );
        2: 1116:            if (nbytes < 0) {
    #####: 1117:                perror("recvfrom (UDS_DGRAM)");
        -: 1118:            } else {
        2: 1119:                buf[nbytes] = '\0';
        2: 1120:                if (save_file_path) {
        2: 1121:                    load_atoms_from_file(save_file_path, 0,0,0);
        -: 1122:                }
        -: 1123:                char response[MAXBUF];
        2: 1124:                parse_and_update_udp(buf, response, sizeof(response));
        2: 1125:                if (save_file_path) {
        2: 1126:                    save_atoms_to_file(save_file_path);
        -: 1127:                }
        2: 1128:                if (sendto(
        -: 1129:                        uds_dgram_fd,
        -: 1130:                        response, strlen(response),
        -: 1131:                        0,
        -: 1132:                        (struct sockaddr*)&cli_un,
        -: 1133:                        cli_len
        -: 1134:                    ) < 0)
        -: 1135:                {
    #####: 1136:                    perror("sendto (UDS_DGRAM)");
        -: 1137:                }
        -: 1138:            }
        2: 1139:            if (timeout_secs > 0) {
    #####: 1140:                alarm(timeout_secs);
    #####: 1141:                timed_out = 0;
        -: 1142:            }
        -: 1143:        }
        -: 1144:
        -: 1145:    } // end of main select‐loop
        -: 1146:
        -: 1147:    // ----------------------------------------------------------------------------
        -: 1148:    // 11) Clean up: close sockets and unlink any UDS files
        -: 1149:    // ----------------------------------------------------------------------------
       21: 1150:    if (tcp_listen_fd >= 0) close(tcp_listen_fd);
       21: 1151:    if (udp_fd >= 0)        close(udp_fd);
       21: 1152:    if (uds_stream_fd >= 0) close(uds_stream_fd);
       21: 1153:    if (uds_dgram_fd >= 0)  close(uds_dgram_fd);
        -: 1154:
       21: 1155:    if (uds_stream_path)   unlink(uds_stream_path);
       21: 1156:    if (uds_dgram_path)    unlink(uds_dgram_path);
        -: 1157:
       21: 1158:    printf("Server exiting cleanly.\n");
       21: 1159:    return 0;
        -: 1160:}
